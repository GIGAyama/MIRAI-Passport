<script>
/**
 * みらいパスポート v1.0
 * Robust Logic & Readable Code Refactoring
 * Update: Child-friendly Rubric Terms & Rich Editor Features
 */

// ==============================================
// Server Communication Wrapper
// ==============================================
const Server = {
  call: (funcName, ...args) => {
    return new Promise((resolve, reject) => {
      google.script.run
        .withSuccessHandler(resolve)
        .withFailureHandler((error) => {
          UI.hideLoading();
          console.error(`Server Error [${funcName}]:`, error);
          Swal.fire('通信エラー', error.message || '予期せぬエラーが発生しました', 'error');
          reject(error);
        })
        [funcName](...args);
    });
  }
};

// ==============================================
// UI Utilities
// ==============================================
const UI = {
  showLoading: (mainText, subText = "しばらくお待ちください") => {
    const txt = document.getElementById('loadingText');
    const sub = document.getElementById('loadingSubText');
    if (txt) txt.innerText = mainText;
    if (sub) sub.innerText = subText;
    document.getElementById('loadingOverlay').classList.remove('d-none');
  },

  hideLoading: () => {
    document.getElementById('loadingOverlay').classList.add('d-none');
  },

  toast: (title, icon = 'success') => {
    Swal.mixin({
      toast: true,
      position: 'top-end',
      showConfirmButton: false,
      timer: 2000
    }).fire({ icon, title });
  },

  updateBatchProgress: (percent, text) => {
    const bar = document.getElementById('batchProgressBar');
    const txt = document.getElementById('batchProgressText');
    if (bar) bar.style.width = `${percent}%`;
    if (txt) txt.innerText = text;
  },

  toggleBatchProgress: (show) => {
    const el = document.getElementById('batchProgressContainer');
    if (el) show ? el.classList.remove('d-none') : el.classList.add('d-none');
  }
};

// ==============================================
// Modal Controllers
// ==============================================
const Modals = {
  openSettings: () => new bootstrap.Modal(document.getElementById('settingsModal')).show(),
  openImport: () => new bootstrap.Modal(document.getElementById('importModal')).show(),
  openPdfImport: () => new bootstrap.Modal(document.getElementById('pdfImportModal')).show(),

  openRubric: () => {
    if (!State.currentTask) return Swal.fire('エラー', '授業を選択してください', 'warning');
    const container = document.getElementById('rubricContainer');
    container.innerHTML = State.currentTask.rubricHtml || 
      `<div class="text-center py-5 text-muted">
         <p class="mb-0">「AI作成」ボタンを押して評価基準を作成してください。</p>
       </div>`;
    new bootstrap.Modal(document.getElementById('rubricModal')).show();
  },

  openDashboard: async () => {
    if (!State.currentTask) return Swal.fire('エラー', '授業を選択してください', 'warning');
    
    UI.showLoading("提出状況を取得中...");
    try {
      let subs = await Server.call('getTaskSubmissions', State.currentTask.id);
      if (!subs) subs = [];
      
      State.dashboardData = subs; // メモリに保存
      const grid = document.getElementById('dashboardGrid');
      grid.innerHTML = '';

      if (subs.length === 0) {
        grid.innerHTML = '<div class="col-12 text-center py-5 text-muted">提出された回答はありません</div>';
      } else {
        subs.forEach((s, index) => {
          const col = document.createElement('div');
          col.className = 'col-md-3 col-sm-6';
          
          const statusBadge = s.status === 'graded' 
            ? '<span class="badge bg-primary">添削済</span>' 
            : '<span class="badge bg-success">提出済</span>';
            
          const imgHtml = s.canvasImage 
            ? `<img src="${s.canvasImage}" style="max-height:100%; max-width:100%; object-fit:contain;">`
            : '<span class="text-muted small">No Image</span>';

          col.innerHTML = `
            <div class="card h-100 shadow-sm" style="cursor:pointer;" onclick="App.openGrading(${index})">
              <div class="card-img-top bg-light d-flex align-items-center justify-content-center" style="height:150px; overflow:hidden;">
                ${imgHtml}
              </div>
              <div class="card-body p-2">
                <h6 class="card-title fw-bold mb-1 text-truncate">${s.studentName}</h6>
                <div class="d-flex justify-content-between align-items-center">
                  ${statusBadge}
                  <small class="text-muted" style="font-size:0.7em">${new Date(s.submittedAt).toLocaleTimeString()}</small>
                </div>
              </div>
            </div>`;
          grid.appendChild(col);
        });
      }
      new bootstrap.Modal(document.getElementById('dashboardModal')).show();
    } finally {
      UI.hideLoading();
    }
  },

  openGallery: async () => {
    UI.showLoading("広場へ移動中...");
    try {
      const items = await Server.call('getSharedResponses', State.currentTask.id);
      const grid = document.getElementById('galleryGrid');
      grid.innerHTML = '';
      
      if (!items || items.length === 0) {
        grid.innerHTML = '<div class="col-12 text-center py-5 text-muted">共有されている作品はありません</div>';
      } else {
        items.forEach(i => {
          const col = document.createElement('div');
          col.className = 'col-md-4 mb-3';
          col.innerHTML = `
            <div class="card h-100 shadow-sm">
              <div class="bg-light d-flex align-items-center justify-content-center" style="height:200px; overflow:hidden;">
                <img src="${i.canvasImage}" class="img-fluid" style="max-height:100%;">
              </div>
              <div class="card-body text-center p-2">
                <small class="fw-bold">${i.studentName}</small>
              </div>
            </div>`;
          grid.appendChild(col);
        });
      }
      new bootstrap.Modal(document.getElementById('galleryModal')).show();
    } finally {
      UI.hideLoading();
    }
  }
};

// ==============================================
// Global State Management
// ==============================================
const State = {
  unitData: null,      // 単元計画データ (JSON)
  currentTask: null,   // 現在選択中の授業タスク
  fabricCanvas: null,  // 手書きキャンバスインスタンス
  isDrawMode: false,   // 手書きモードフラグ
  ocrCache: "",        // OCR解析結果テキスト
  studentId: null,     // 児童ID (LocalStorage)
  gradingRow: null,    // 添削中の行番号
  dashboardData: []    // ダッシュボード用データキャッシュ
};

// ==============================================
// Main Application Logic
// ==============================================
const App = {
  
  // --- Initialization ---
  init: async () => {
    // Student Setup
    if (APP_CONFIG.mode === 'student') {
      State.studentId = localStorage.getItem('manabi_sid');
      if (!State.studentId) {
        State.studentId = 'S_' + Date.now() + Math.random().toString(36).substr(2, 5);
        localStorage.setItem('manabi_sid', State.studentId);
      }
      // Auto-save loop
      setInterval(App.autoSaveLocal, 10000);
    }

    // View Setup
    if (APP_CONFIG.mode === 'teacher') {
      UI.showLoading("システムを起動しています", "ユーザー設定を確認中...");
      const status = await Server.call('checkSetupStatus');
      if (status.isSetup) {
        document.getElementById('setupWizard').classList.add('d-none');
        document.getElementById('appContainer').classList.remove('d-none');
        App.loadConfig();
        // ★ Editor機能の初期化
        Editor.init();
      } else {
        UI.hideLoading();
        document.getElementById('setupWizard').classList.remove('d-none');
      }
    } else {
      // Student View
      UI.showLoading("ワークシートを準備しています", "課題データをダウンロード中...");
      document.getElementById('appContainer').classList.remove('d-none');
      if (APP_CONFIG.taskId) {
        App.loadFromHistory(APP_CONFIG.taskId);
      } else {
        UI.hideLoading();
        Swal.fire('エラー', '課題IDが無効です。URLを確認してください。', 'error');
      }
    }
  },

  performSetup: async () => {
    UI.showLoading("データベースを構築しています", "初期化処理を実行中...");
    try {
      await Server.call('performInitialSetup');
      location.reload(); // リロードして設定を反映
    } catch (e) {
      console.error(e);
    }
  },

  loadConfig: async () => {
    const config = await Server.call('getUserConfig');
    document.getElementById('apiKeyInput').value = config.apiKey;
    document.getElementById('teacherNameInput').value = config.teacherName;
    UI.hideLoading();
    App.loadHistory();
  },

  saveSettings: async () => {
    await Server.call('saveUserConfig',
      document.getElementById('apiKeyInput').value,
      document.getElementById('teacherNameInput').value
    );
    UI.toast('設定を保存しました');
    bootstrap.Modal.getInstance(document.getElementById('settingsModal')).hide();
  },

  // --- Data Management (JSON Import) ---

  processImport: () => {
    try {
      const inputVal = document.getElementById('jsonInput').value;
      
      // クリーニング: Markdown記法や余計な文字を削除してJSON部分を抽出
      const firstBrace = inputVal.indexOf('{');
      const lastBrace = inputVal.lastIndexOf('}');
      
      if (firstBrace === -1 || lastBrace === -1) {
        throw new Error("有効なJSONデータが見つかりません。");
      }
      
      const jsonString = inputVal.substring(firstBrace, lastBrace + 1);
      const json = JSON.parse(jsonString);

      // 簡易バリデーション
      if (!json.tasks || !Array.isArray(json.tasks)) {
        throw new Error("JSONデータに 'tasks' 配列が含まれていません。");
      }

      State.unitData = json;
      App.renderTaskList();
      
      bootstrap.Modal.getInstance(document.getElementById('importModal')).hide();
      UI.toast('計画を読み込みました');
      
    } catch (e) {
      console.error(e);
      Swal.fire({
        icon: 'error',
        title: 'JSON読み込みエラー',
        text: '形式が正しくありません。エラー詳細: ' + e.message,
        footer: 'AIが生成したコードブロック(```json)が含まれていても自動除去しますが、構文自体が壊れている可能性があります。'
      });
    }
  },

  loadSampleJson: () => {
    const sample = {
      "unitInfo": { "subject": "国語", "grade": 5, "unitName": "注文の多い料理店" },
      "tasks": [
        { "id": "t1", "category": "つかむ", "title": "導入: 扉の向こうへ", "description": "物語の入り口を読む" },
        { "id": "t2", "category": "まなぶ", "title": "色と音の表現", "description": "宮沢賢治の表現技法を探す" }
      ]
    };
    document.getElementById('jsonInput').value = JSON.stringify(sample, null, 2);
  },

  renderTaskList: () => {
    const list = document.getElementById('taskList');
    list.innerHTML = '';
    
    if (!State.unitData || !State.unitData.tasks) return;
    document.getElementById('taskCount').innerText = State.unitData.tasks.length + '件';
    
    State.unitData.tasks.forEach(task => {
      const div = document.createElement('div');
      div.className = 'list-group-item d-flex p-2 align-items-center';
      div.innerHTML = `
        <div class="me-2">
          <input class="form-check-input task-checkbox" type="checkbox" value="${task.id}" checked>
        </div>
        <button class="btn btn-link text-start text-dark p-0 w-100 text-decoration-none shadow-none" type="button">
          <div class="d-flex justify-content-between align-items-center">
            <small class="badge bg-secondary rounded-pill">${task.category || '学習'}</small>
            <small class="text-muted">${task.step || ''}</small>
          </div>
          <div class="fw-bold text-truncate small mt-1">${task.title || '無題'}</div>
        </button>`;
      
      // 安全なイベントリスナー設定 (IDで紐付け)
      const btn = div.querySelector('button');
      btn.onclick = () => App.selectTaskById(task.id);
      
      list.appendChild(div);
    });
  },

  toggleSelectAll: (cb) => {
    document.querySelectorAll('.task-checkbox').forEach(box => box.checked = cb.checked);
  },

  // --- Task Selection & Editor ---

  selectTaskById: (taskId) => {
    const task = State.unitData.tasks.find(t => t.id === taskId);
    if (task) App.selectTask(task);
  },

  selectTask: async (task) => {
    State.currentTask = task;
    
    // UI表示切替
    document.getElementById('emptyState')?.classList.add('d-none');
    document.getElementById('paperArea').classList.remove('d-none');
    document.getElementById('editorToolbar').classList.remove('d-none');
    document.getElementById('currentTaskTitle').innerText = task.title || "無題";
    
    // キャンバスリセット
    try { App.resetCanvas(); } catch(e) { console.warn(e); }
    
    document.getElementById('worksheetContent').contentEditable = (APP_CONFIG.mode === 'teacher');
    
    UI.showLoading("データを取得中...");
    
    try {
      const data = await Server.call('loadWorksheetFromDB', task.id);
      
      if (data) {
        document.getElementById('worksheetContent').innerHTML = data.htmlContent;
        State.currentTask.rubricHtml = data.rubricHtml;
        if (data.canvasJson) State.currentTask.canvasData = data.canvasJson;
        
        if (APP_CONFIG.mode === 'student') {
          setTimeout(async () => {
            App.toggleDrawMode(true);
            await App.loadMyResponse();
          }, 500);
        }
      } else {
        // データなし（未作成）の場合
        const info = State.unitData?.unitInfo || {};
        document.getElementById('worksheetContent').innerHTML = `
          <div class="d-flex flex-column align-items-center justify-content-center h-100 text-muted">
            <div class="ws-header w-100">
              <div>${info.grade || ''} ${info.unitName || ''}</div>
              <div>名前: __________________</div>
            </div>
            <h1>${task.title}</h1>
            <div class="my-5 text-center">
              <p class="mb-4">この授業のワークシートはまだ作成されていません。</p>
              <button class="btn btn-primary btn-lg rounded-pill px-5 shadow-sm" onclick="App.generateSingleWorksheet()">
                <i class="bi bi-stars"></i> AIで作成する
              </button>
            </div>
          </div>`;
      }
      
      // ★ 読み込み後に編集機能を有効化
      if(APP_CONFIG.mode === 'teacher') Editor.enableResizing();

    } finally {
      UI.hideLoading();
    }
  },

  // --- History Management ---

  loadHistory: async () => {
    const history = await Server.call('getHistory');
    const list = document.getElementById('historyList');
    list.innerHTML = '';
    
    history.forEach(h => {
      const btn = document.createElement('button');
      btn.className = 'list-group-item list-group-item-action small py-2';
      btn.innerHTML = `
        <div class="fw-bold text-truncate">${h.title}</div>
        <small class="text-muted" style="font-size:0.75rem">
          ${new Date(h.timestamp).toLocaleDateString()} ${new Date(h.timestamp).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}
        </small>`;
      btn.onclick = () => App.loadFromHistory(h.id);
      list.appendChild(btn);
    });
  },

  loadFromHistory: async (taskId) => {
    UI.showLoading("履歴を展開中...", "データを復元しています");
    try {
      App.resetCanvas();
      const data = await Server.call('loadWorksheetFromDB', taskId);
      
      if (data) {
        // 画面表示
        document.getElementById('paperArea').classList.remove('d-none');
        document.getElementById('editorToolbar').classList.remove('d-none');
        document.getElementById('emptyState')?.classList.add('d-none');
        
        document.getElementById('worksheetContent').innerHTML = data.htmlContent;
        document.getElementById('currentTaskTitle').innerText = data.stepTitle;
        document.getElementById('worksheetContent').contentEditable = (APP_CONFIG.mode === 'teacher');

        // データ構造の復元（レガシー互換性確保）
        State.currentTask = {
          id: data.taskId,
          title: data.stepTitle,
          description: "", // 履歴からは説明文が取れない場合がある
          canvasData: data.canvasJson,
          rubricHtml: data.rubricHtml,
          ... (data.jsonSource || {})
        };
        State.currentTask.title = data.stepTitle; // 確実なタイトル

        State.unitData = {
          unitInfo: { unitName: data.unitName || "復元された単元" },
          tasks: [State.currentTask]
        };

        if (APP_CONFIG.mode === 'teacher') App.renderTaskList();
        
        if (APP_CONFIG.mode === 'student') {
          setTimeout(async () => {
            App.toggleDrawMode(true);
            await App.loadMyResponse();
          }, 500);
        }
        
        // ★ 履歴展開後も編集機能有効化
        if(APP_CONFIG.mode === 'teacher') Editor.enableResizing();
        
      } else {
        Swal.fire('エラー', 'データが見つかりません。削除された可能性があります。', 'error');
      }
    } catch (e) {
      console.error(e);
      Swal.fire('読込エラー', '履歴の展開に失敗しました。', 'error');
    } finally {
      UI.hideLoading();
    }
  },

  // --- AI Generation ---

  generateSingleWorksheet: async (useOcr = false) => {
    if (!State.currentTask) return;
    UI.showLoading("AIが執筆中です", "レイアウトを構成しています...");
    try {
      let extraContext = "";
      if (useOcr && State.ocrCache) {
        extraContext = `\n【参考資料テキスト】\n${State.ocrCache.substring(0, 1500)}...\n※この資料の内容を授業に反映させてください。`;
      }

      const info = State.unitData?.unitInfo || { grade: "", unitName: "" };
      
      // プロンプト改善: リッチなヘッダー・フッターを含むHTMLテンプレートを強制
      const prompt = `
        あなたは日本の小学校教師です。以下の授業情報から、児童が取り組むためのワークシートのHTML(body内部のみ)を作成してください。
        
        【授業情報】
        学年: ${info.grade}
        単元名: ${info.unitName}
        授業タイトル: ${State.currentTask.title}
        活動内容: ${State.currentTask.description}
        ${extraContext}
        
        【出力HTMLの構成（厳守）】
        以下のHTML構造をテンプレートとしてそのまま使用し、「3. 本文エリア」の中身のみを活動内容に合わせて記述してください。
        Markdown記法(\`\`\`html)は禁止です。

        <!-- 1. リッチヘッダー -->
        <div class="ws-header" style="display:flex; justify-content:space-between; align-items:end; border-bottom: 3px double #555; padding-bottom: 10px; margin-bottom: 20px; font-family: 'Zen Maru Gothic', sans-serif;">
           <div>
             <span style="background:#333; color:#fff; padding:2px 8px; border-radius:4px; font-size:0.7em; margin-right:5px;">${info.grade}</span>
             <span style="font-weight:bold; color:#333;">${info.unitName}</span>
           </div>
           <div style="text-align:right; font-size:0.9em;">
             <span style="margin-right:15px;">年　組　番</span>
             <span style="font-weight:bold; font-size:1.1em;">名前 __________________</span>
           </div>
        </div>

        <!-- 2. タイトル（本文内での重複禁止） -->
        <h1 style="text-align:center; font-size:1.8em; margin-bottom:30px; border-bottom:1px solid #ddd; padding-bottom:10px;">${State.currentTask.title}</h1>

        <!-- 3. 本文エリア（ここをAIが生成） -->
        <!-- 挨拶文不要。具体的な問いと記述欄(ws-lines, ws-box)を中心に構成 -->
        <div style="min-height: 400px;">
          (ここに学習課題・問い・記述欄を生成。クラス名: ws-box, ws-lines, table table-bordered を活用)
        </div>

        <!-- 4. コンパクトフッター（振り返り＆自己評価） -->
        <div style="margin-top: 30px; border-top: 2px dashed #ccc; padding-top: 15px; display: flex; gap: 15px; align-items: start;">
          <!-- 振り返り (60%) -->
          <div style="flex: 6;">
            <div style="font-weight:bold; font-size:0.9em; margin-bottom:5px; color:#555;">■ ふりかえり</div>
            <div class="ws-lines" style="height: 4.5em; background-image: linear-gradient(#ccc 1px, transparent 1px); background-size: 100% 1.5em; line-height: 1.5em;"></div>
          </div>
          <!-- 自己評価 (40%) -->
          <div style="flex: 4;">
            <div style="font-weight:bold; font-size:0.9em; margin-bottom:5px; color:#555;">■ 自己評価</div>
            <table class="table table-bordered table-sm mb-0" style="font-size: 0.75em; text-align:center; background:#fff;">
              <tr><td class="bg-light text-start">わかった・できた</td><td width="60" style="vertical-align:middle;">A B C</td></tr>
              <tr><td class="bg-light text-start">考えた・表した</td><td style="vertical-align:middle;">A B C</td></tr>
              <tr><td class="bg-light text-start">進んで学んだ</td><td style="vertical-align:middle;">A B C</td></tr>
            </table>
          </div>
        </div>

        【配慮】
        低学年の場合は漢字を減らし、平易な表現にしてください。
      `;

      let html = await Server.call('callGeminiAPI', prompt);
      
      // クリーニング
      html = App.cleanAIOutput(html);
      
      // 自動保存
      await Server.call('saveWorksheetToDB', {
        taskId: State.currentTask.id,
        unitName: info.unitName,
        stepTitle: State.currentTask.title,
        htmlContent: html,
        jsonSource: State.currentTask
      });
      
      App.selectTask(State.currentTask); // 再読み込みして表示
      
    } catch (e) {
      console.error(e);
      Swal.fire('生成エラー', 'AIによる生成に失敗しました。時間をおいて試してください。', 'error');
    } finally {
      UI.hideLoading();
    }
  },

  cleanAIOutput: (text) => {
    if (!text) return "";
    return text
      .replace(/```html/gi, "")
      .replace(/```/g, "")
      .replace(/^[\s\S]*?<body[^>]*>/i, "") // bodyタグ以前削除
      .replace(/<\/body>[\s\S]*$/i, "")     // bodyタグ以降削除
      .trim();
  },

  startBatchGeneration: async () => {
    const checkboxes = document.querySelectorAll('.task-checkbox:checked');
    if (checkboxes.length === 0) return Swal.fire('選択なし', '生成するタスクを選択してください', 'info');

    const queue = Array.from(checkboxes).map(cb => State.unitData.tasks.find(t => t.id === cb.value));
    if (!confirm(`${queue.length}件のワークシートを一括生成しますか？`)) return;

    UI.showLoading("一括生成を開始します", "しばらくそのままお待ちください...");
    UI.toggleBatchProgress(true);
    
    const info = State.unitData.unitInfo;

    try {
      for (let i = 0; i < queue.length; i++) {
        const task = queue[i];
        UI.updateBatchProgress(Math.round(((i) / queue.length) * 100), `${i + 1} / ${queue.length}: ${task.title}`);
        
        try {
          // 一括生成用も同様にプロンプトをテンプレート化
          const prompt = `
            あなたは小学校教師です。以下の授業情報からワークシートHTMLを作成してください。
            
            授業情報: 学年:${info.grade}, 単元:${info.unitName}, タイトル:${task.title}, 活動:${task.description}
            
            【出力HTML構成（厳守）】
            <!-- 1. ヘッダー -->
            <div class="ws-header" style="display:flex; justify-content:space-between; align-items:end; border-bottom: 3px double #555; padding-bottom: 10px; margin-bottom: 20px;">
               <div><span style="background:#333; color:#fff; padding:2px 8px; border-radius:4px; font-size:0.8em;">${info.grade}</span> <b>${info.unitName}</b></div>
               <div style="text-align:right;">年 組 番 <b>名前 __________</b></div>
            </div>
            
            <!-- 2. タイトル -->
            <h1 style="text-align:center; margin-bottom:30px; border-bottom:1px solid #ddd;">${task.title}</h1>
            
            <!-- 3. 本文 (ここを生成) -->
            <div style="min-height: 400px;">
              (問いと記述欄を生成)
            </div>
            
            <!-- 4. フッター -->
            <div style="margin-top: 30px; border-top: 2px dashed #ccc; padding-top: 15px; display: flex; gap: 15px;">
              <div style="flex: 6;">
                <div style="font-weight:bold; font-size:0.9em; margin-bottom:5px;">■ ふりかえり</div>
                <div class="ws-lines" style="height: 4.5em; background-image: linear-gradient(#ccc 1px, transparent 1px); background-size: 100% 1.5em;"></div>
              </div>
              <div style="flex: 4;">
                <div style="font-weight:bold; font-size:0.9em; margin-bottom:5px;">■ 自己評価</div>
                <table class="table table-bordered table-sm mb-0" style="font-size: 0.75em; text-align:center;">
                  <tr><td class="bg-light">わかった・できた</td><td>A B C</td></tr>
                  <tr><td class="bg-light">考えた・表した</td><td>A B C</td></tr>
                  <tr><td class="bg-light">進んで学んだ</td><td>A B C</td></tr>
                </table>
              </div>
            </div>
          `;
          
          let html = await Server.call('callGeminiAPI', prompt);
          html = App.cleanAIOutput(html);
          
          await Server.call('saveWorksheetToDB', {
            taskId: task.id,
            unitName: info.unitName,
            stepTitle: task.title,
            htmlContent: html,
            jsonSource: task
          });
        } catch (e) {
          console.error(`Task ${task.title} failed:`, e);
        }
        
        // Rate Limit回避のための待機
        await new Promise(r => setTimeout(r, 1500));
      }
      
      UI.updateBatchProgress(100, '完了');
      App.loadHistory();
      UI.toast('一括生成が完了しました');
      
    } finally {
      setTimeout(() => {
        UI.toggleBatchProgress(false);
        UI.hideLoading();
      }, 1000);
    }
  },

  saveCurrentWorksheet: async () => {
    if (!State.currentTask) return;
    UI.showLoading("保存しています", "クラウドに同期中...");
    
    const content = document.getElementById('worksheetContent').innerHTML;
    let canvasJson = null;
    if (State.fabricCanvas) canvasJson = State.fabricCanvas.toJSON();

    const data = {
      taskId: State.currentTask.id,
      unitName: State.unitData?.unitInfo?.unitName,
      stepTitle: State.currentTask.title,
      htmlContent: content,
      jsonSource: State.currentTask,
      canvasJson: canvasJson,
      rubricHtml: State.currentTask.rubricHtml
    };

    try {
      await Server.call('saveWorksheetToDB', data);
      UI.toast("保存しました");
      if (APP_CONFIG.mode === 'teacher') App.loadHistory();
    } finally {
      UI.hideLoading();
    }
  },

  createPdf: async () => {
    if (!State.currentTask) return;
    UI.showLoading("PDFを作成しています", "サーバーでレンダリング中...");
    try {
      let html = document.getElementById('worksheetContent').innerHTML;
      // キャンバスを画像化して埋め込み
      if (State.fabricCanvas) {
        const img = State.fabricCanvas.toDataURL();
        html += `<img src="${img}" style="position:absolute; top:0; left:0; width:100%; height:100%; z-index:99; pointer-events:none;">`;
      }
      const result = await Server.call('createPdf', html, State.currentTask.title);
      window.open(result.downloadUrl, '_blank');
    } finally {
      UI.hideLoading();
    }
  },

  // --- Student & Grading Logic ---
  
  autoSaveLocal: () => {
    if (APP_CONFIG.mode !== 'student' || !State.currentTask || !State.fabricCanvas) return;
    const key = `manabi_${State.currentTask.id}`;
    localStorage.setItem(key, JSON.stringify({ j: State.fabricCanvas.toJSON(), t: Date.now() }));
    const ind = document.getElementById('autoSaveIndicator');
    if(ind) ind.innerHTML = `<i class="bi bi-cloud-check"></i> ${new Date().toLocaleTimeString()}`;
  },

  loadMyResponse: async () => {
    const resp = await Server.call('getMyResponse', State.currentTask.id, State.studentId);
    if (resp) {
      if (resp.canvasJson && State.fabricCanvas) State.fabricCanvas.loadFromJSON(resp.canvasJson);
      if (resp.feedbackText || resp.status === 'graded') {
        const btn = document.getElementById('btnFeedback');
        if(btn) {
          btn.classList.remove('d-none');
          btn.onclick = () => Swal.fire({ title: '先生からのコメント', text: resp.feedbackText || "（コメントなし）", icon: 'info' });
          UI.toast("添削が届いています");
        }
      }
    } else {
      // Restore Local Draft
      const local = localStorage.getItem(`manabi_${State.currentTask.id}`);
      if (local && State.fabricCanvas) {
        State.fabricCanvas.loadFromJSON(JSON.parse(local).j);
        UI.toast("下書きを復元しました");
      }
    }
  },

  submitStudentResponse: async (status) => {
    const name = document.getElementById('studentNameInput').value;
    if (!name && status === 'submitted') return Swal.fire('名前を入力してください', '', 'warning');
    
    UI.showLoading(status === 'draft' ? "一時保存中..." : "提出しています", "先生にデータを送信中...");
    try {
      let img = "";
      if (State.fabricCanvas) img = State.fabricCanvas.toDataURL({ format: 'png', multiplier: 0.5 });
      
      await Server.call('saveStudentResponse', {
        taskId: State.currentTask.id,
        studentId: State.studentId,
        studentName: name || "名無し",
        canvasImage: img,
        canvasJson: JSON.stringify(State.fabricCanvas?.toJSON()),
        textContent: "",
        status: status
      });
      
      if (status === 'submitted') localStorage.removeItem(`manabi_${State.currentTask.id}`);
      UI.toast(status === 'draft' ? "保存しました" : "提出しました！");
    } finally {
      UI.hideLoading();
    }
  },

  // --- Teacher Grading ---
  openGrading: (index) => {
    const s = State.dashboardData[index];
    State.gradingRow = s.rowIndex;
    
    bootstrap.Modal.getInstance(document.getElementById('dashboardModal')).hide();
    
    const container = document.getElementById('gradingContainer');
    // 現在のワークシート背景を表示
    container.innerHTML = `<div id="gradingPaper" class="sheet shadow-sm"><div class="p-5">${document.getElementById('worksheetContent').innerHTML}</div></div><canvas id="gradingCanvas"></canvas>`;
    
    new bootstrap.Modal(document.getElementById('gradingModal')).show();
    
    setTimeout(() => {
      const paper = document.getElementById('gradingPaper');
      const cv = document.getElementById('gradingCanvas');
      cv.width = paper.offsetWidth;
      cv.height = paper.offsetHeight;
      cv.style.position = 'absolute';
      cv.style.top = paper.offsetTop + 'px';
      cv.style.left = paper.offsetLeft + 'px';
      cv.style.zIndex = 99;
      
      const gCanvas = new fabric.Canvas('gradingCanvas', { isDrawingMode: true });
      gCanvas.freeDrawingBrush.width = 3;
      gCanvas.freeDrawingBrush.color = "red"; // 赤ペン固定
      
      if (s.canvasJson) gCanvas.loadFromJSON(s.canvasJson);
      
      State.gradingCanvas = gCanvas;
      document.getElementById('gradingTitle').innerText = `${s.studentName} さんの回答`;
      document.getElementById('feedbackTextInput').value = s.feedbackText || "";
    }, 500);
  },

  saveGrading: async () => {
    if (!State.gradingRow) return;
    UI.showLoading("返却しています", "コメントと添削内容を保存中...");
    try {
      await Server.call('saveFeedback', {
        rowIndex: State.gradingRow,
        feedbackText: document.getElementById('feedbackTextInput').value,
        canvasJson: JSON.stringify(State.gradingCanvas.toJSON())
      });
      bootstrap.Modal.getInstance(document.getElementById('gradingModal')).hide();
      UI.toast("返却しました");
    } finally {
      UI.hideLoading();
    }
  },

  // --- Other Utils ---
  generateRubric: async () => {
    UI.showLoading("ルーブリック作成中...");
    try {
      let h = await Server.call('generateRubricAI', {
        unitName: "",
        stepTitle: State.currentTask.title,
        description: State.currentTask.description
      });
      h = App.cleanAIOutput(h);
      document.getElementById('rubricContainer').innerHTML = h;
    } finally {
      UI.hideLoading();
    }
  },

  saveRubric: () => {
    State.currentTask.rubricHtml = document.getElementById('rubricContainer').innerHTML;
    App.saveCurrentWorksheet();
    bootstrap.Modal.getInstance(document.getElementById('rubricModal')).hide();
  },

  showShareUrl: async () => {
    if (!State.currentTask) return;
    const url = await Server.call('getWebAppUrl');
    const shareUrl = `${url}?mode=student&taskId=${State.currentTask.id}`;
    document.getElementById('shareUrlInput').value = shareUrl;
    new bootstrap.Modal(document.getElementById('shareModal')).show();
  },

  processOcrImport: async () => { /* OCR Logic (Abbreviated for safety) */ },

  // Fabric Canvas
  initFabric: () => {
    if (!State.fabricCanvas) {
      const c = document.getElementById('drawCanvas');
      if (c) State.fabricCanvas = new fabric.Canvas('drawCanvas', { isDrawingMode: false });
    }
  },

  resetCanvas: () => {
    if (State.fabricCanvas) {
      try { State.fabricCanvas.clear(); State.fabricCanvas.dispose(); } catch(e){}
      State.fabricCanvas = null;
    }
    const cv = document.getElementById('drawCanvas');
    if (cv) cv.classList.add('d-none');
    App.toggleDrawMode(false);
  },

  toggleDrawMode: (forceState) => {
    const newState = (forceState !== undefined) ? forceState : !State.isDrawMode;
    State.isDrawMode = newState;
    
    const btn = document.getElementById('btnDrawMode');
    const tools = document.getElementById('drawTools');
    const cv = document.getElementById('drawCanvas');
    const pp = document.getElementById('paperArea');

    if(btn) btn.classList.replace(newState ? 'btn-outline-dark' : 'btn-dark', newState ? 'btn-dark' : 'btn-outline-dark');
    if(tools) newState ? tools.classList.remove('d-none') : tools.classList.add('d-none');

    if (newState) {
      if(cv) {
        cv.classList.remove('d-none');
        cv.style.position = 'absolute'; cv.style.left = '0'; cv.style.top = '0';
        if(pp) { cv.width = pp.offsetWidth; cv.height = pp.offsetHeight; }
      }
      
      if (!State.fabricCanvas && cv) {
        try { State.fabricCanvas = new fabric.Canvas('drawCanvas', { isDrawingMode: true, freeDrawingBrush: { width: 3, color: '#ff0000' } }); } catch(e){}
      } else if (State.fabricCanvas) {
        State.fabricCanvas.isDrawingMode = true;
      }
      
      if (State.currentTask?.canvasData && State.fabricCanvas) {
        try { State.fabricCanvas.loadFromJSON(State.currentTask.canvasData); } catch(e){}
      }
      const wc = document.getElementById('worksheetContent');
      if(wc) wc.contentEditable = false;
    } else {
      if (State.fabricCanvas) State.fabricCanvas.isDrawingMode = false;
      const cnt = document.querySelector('.canvas-container');
      if(cnt) cnt.style.pointerEvents = 'none';
      const wc = document.getElementById('worksheetContent');
      if(wc) wc.contentEditable = true;
    }
  },

  updateBrush: () => { if (State.fabricCanvas) State.fabricCanvas.freeDrawingBrush.color = document.getElementById('penColor').value; },
  clearCanvas: () => { if (State.fabricCanvas) State.fabricCanvas.clear(); },
  insertImage: (input) => { /* Image Insert Logic (Same as v11.0) */ 
    if(input.files && input.files[0]){
      const r = new FileReader();
      r.onload = e => {
        const i = new Image();
        i.onload = () => {
          const c = document.createElement('canvas'), x = c.getContext('2d'), M = 800;
          let w=i.width, h=i.height;
          if(w>h){if(w>M){h*=M/w;w=M}}else{if(h>M){w*=M/h;h=M}}
          c.width=w; c.height=h; x.drawImage(i,0,0,w,h);
          const u = c.toDataURL('image/jpeg', 0.7);
          
          if(State.isDrawMode && State.fabricCanvas) {
            fabric.Image.fromURL(u, o => {
              o.scaleToWidth(300);
              State.fabricCanvas.add(o);
              State.fabricCanvas.centerObject(o);
            });
          } else {
            App.insertAtCursor(`<img src="${u}" style="max-width:100%; border:1px solid #ccc; display:block; margin:10px auto;">`);
          }
        };
        i.src = e.target.result;
      };
      r.readAsDataURL(input.files[0]);
    }
    input.value = '';
  },
  insertAtCursor: (html) => {
    const e = document.getElementById('worksheetContent');
    e.focus();
    const s = window.getSelection();
    if(s.getRangeAt && s.rangeCount) {
      const r = s.getRangeAt(0);
      if(e.contains(r.commonAncestorContainer)) {
        r.deleteContents();
        const d = document.createElement("div");
        d.innerHTML = html;
        const f = document.createDocumentFragment();
        let n;
        while((n=d.firstChild)) f.appendChild(n);
        r.insertNode(f);
        return;
      }
    }
    e.insertAdjacentHTML('beforeend', html);
  }
};

// ==============================================
// Rich Editor Module (Context Menu & Resizing)
// ==============================================
const Editor = {
  currentTarget: null,

  init: () => {
    // 1. Create Context Menu DOM
    const menu = document.createElement('div');
    menu.id = 'ctxMenu';
    menu.className = 'dropdown-menu shadow';
    menu.style.position = 'fixed';
    menu.style.display = 'none';
    menu.style.zIndex = '9999';
    document.body.appendChild(menu);

    // 2. Global Event Listeners
    document.addEventListener('contextmenu', (e) => {
      // ワークシート内のみ反応
      const ws = document.getElementById('worksheetContent');
      if (!ws || !ws.contains(e.target)) return;

      e.preventDefault();
      Editor.showContextMenu(e, menu);
    });

    document.addEventListener('click', () => menu.style.display = 'none');
    
    // 3. Inject Styles for Resizing & Hover
    Editor.enableResizing();
  },

  enableResizing: () => {
    // 既存のスタイルタグがあれば削除して再作成（重複防止）
    const oldStyle = document.getElementById('editor-style');
    if(oldStyle) oldStyle.remove();

    const style = document.createElement('style');
    style.id = 'editor-style';
    style.innerHTML = `
      .ws-box, .ws-lines { 
        resize: vertical; 
        overflow: hidden; /* ハンドル表示に必須 (visible以外) */
        position: relative;
        min-height: 50px;
      }
      /* 印刷時にハンドルを消す */
      @media print { .ws-box, .ws-lines { resize: none; overflow: visible; } }
      
      /* 編集モード時の視覚フィードバック */
      #worksheetContent[contenteditable="true"] .ws-box:hover,
      #worksheetContent[contenteditable="true"] .ws-lines:hover,
      #worksheetContent[contenteditable="true"] table:hover {
        outline: 2px dashed #a2d2ff;
        cursor: text;
      }
    `;
    document.head.appendChild(style);
  },

  showContextMenu: (e, menu) => {
    const t = e.target;
    let items = [];
    Editor.currentTarget = t;

    // テーブル操作
    const td = t.closest('td, th');
    if (td) {
      items = [
        { label: '<i class="bi bi-arrow-bar-up"></i> 行を上に追加', action: () => Editor.tableAction('addRowUp', td) },
        { label: '<i class="bi bi-arrow-bar-down"></i> 行を下に追加', action: () => Editor.tableAction('addRowDown', td) },
        { divider: true },
        { label: '<i class="bi bi-arrow-bar-left"></i> 列を左に追加', action: () => Editor.tableAction('addColLeft', td) },
        { label: '<i class="bi bi-arrow-bar-right"></i> 列を右に追加', action: () => Editor.tableAction('addColRight', td) },
        { divider: true },
        { label: '<i class="bi bi-trash"></i> 行を削除', action: () => Editor.tableAction('delRow', td) },
        { label: '<i class="bi bi-trash"></i> 列を削除', action: () => Editor.tableAction('delCol', td) }
      ];
    } 
    // ボックス操作 (.ws-box, .ws-lines)
    else if (t.classList.contains('ws-box') || t.classList.contains('ws-lines')) {
      items = [
        { label: '<i class="bi bi-files"></i> ボックスを複製', action: () => Editor.cloneElement(t) },
        { label: '<i class="bi bi-trash"></i> 削除', action: () => t.remove() }
      ];
    }
    // 一般テキスト操作
    else {
      items = [
        { label: '<i class="bi bi-type-bold"></i> 太字', action: () => document.execCommand('bold') },
        { label: '<i class="bi bi-trash"></i> 削除', action: () => t.remove() }
      ];
    }

    if (items.length === 0) return;

    // メニュー構築
    menu.innerHTML = '';
    items.forEach(i => {
      if (i.divider) {
        menu.innerHTML += '<div class="dropdown-divider"></div>';
      } else {
        const a = document.createElement('a');
        a.className = 'dropdown-item';
        a.href = '#';
        a.innerHTML = i.label;
        a.onclick = (ev) => { ev.preventDefault(); i.action(); };
        menu.appendChild(a);
      }
    });

    // 表示位置
    menu.style.left = `${e.pageX}px`;
    menu.style.top = `${e.pageY}px`;
    menu.style.display = 'block';
  },

  tableAction: (type, cell) => {
    const row = cell.parentElement;
    const table = row.parentElement.parentElement; // thead/tbody -> table
    const rowIndex = row.rowIndex;
    const colIndex = cell.cellIndex;

    switch(type) {
      case 'addRowUp': table.insertRow(rowIndex); break;
      case 'addRowDown': table.insertRow(rowIndex + 1); break;
      case 'delRow': table.deleteRow(rowIndex); break;
      case 'addColLeft': 
        for (let r of table.rows) r.insertCell(colIndex); 
        break;
      case 'addColRight': 
        for (let r of table.rows) r.insertCell(colIndex + 1); 
        break;
      case 'delCol': 
        for (let r of table.rows) r.deleteCell(colIndex); 
        break;
    }
    // 新しいセルの中身を空にするなどの初期化が必要ならここで行う
    // 簡易的に空セルを追加している
  },

  cloneElement: (el) => {
    const clone = el.cloneNode(true);
    el.after(clone);
  }
};

document.addEventListener('DOMContentLoaded', App.init);
</script>
