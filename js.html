<script>
/**
 * みらいパスポート v2.1
 * Update: Unified Print System (Integrated)
 * Keeps all previous features (Stamps, Plaza, Edit Lock) intact.
 */

// ==============================================
// Server Communication Wrapper
// ==============================================
const Server = {
  call: (funcName, ...args) => {
    return new Promise((resolve, reject) => {
      google.script.run
        .withSuccessHandler(resolve)
        .withFailureHandler((error) => {
          UI.hideLoading();
          console.error(`Server Error [${funcName}]:`, error);
          Swal.fire('通信エラー', error.message || '予期せぬエラーが発生しました', 'error');
          reject(error);
        })
        [funcName](...args);
    });
  }
};

// ==============================================
// UI Utilities
// ==============================================
const UI = {
  showLoading: (mainText, subText = "しばらくお待ちください") => {
    const txt = document.getElementById('loadingText');
    const sub = document.getElementById('loadingSubText');
    if (txt) txt.innerText = mainText;
    if (sub) sub.innerText = subText;
    document.getElementById('loadingOverlay').classList.remove('d-none');
  },

  hideLoading: () => {
    document.getElementById('loadingOverlay').classList.add('d-none');
  },

  toast: (title, icon = 'success') => {
    Swal.mixin({
      toast: true,
      position: 'top-end',
      showConfirmButton: false,
      timer: 2000
    }).fire({ icon, title });
  },

  updateBatchProgress: (percent, text) => {
    const bar = document.getElementById('batchProgressBar');
    const txt = document.getElementById('batchProgressText');
    if (bar) bar.style.width = `${percent}%`;
    if (txt) txt.innerText = text;
  },

  toggleBatchProgress: (show) => {
    const el = document.getElementById('batchProgressContainer');
    if (el) show ? el.classList.remove('d-none') : el.classList.add('d-none');
  }
};

// ==============================================
// ★ Unified Print System (New)
// ==============================================
const Printer = {
  /**
   * 統一印刷ロジック: 別ウィンドウを開いて印刷を実行
   * @param {Array} pages - { html: string, img: string(base64/url) } の配列
   */
  run: (pages) => {
    if (!pages || pages.length === 0) return;

    // 1. 新しいウィンドウを開く
    const win = window.open('', '_blank');
    if (!win) {
      return Swal.fire('エラー', 'ポップアップがブロックされました。許可してください。', 'error');
    }

    // 2. 現在のスタイルシートを収集 (Bootstrapやフォント等)
    const styles = Array.from(document.querySelectorAll('link[rel="stylesheet"], style'))
      .map(el => el.outerHTML)
      .join('');

    // 3. 印刷専用CSS (ウィンドウ内でのみ有効)
    const printCss = `
      <style>
        body { 
          margin: 0; padding: 0; background: white; 
          font-family: "Zen Maru Gothic", sans-serif;
        }
        @media print {
          @page { margin: 0; size: A4; }
          body { margin: 0; padding: 0; }
          .print-sheet {
            width: 100%;
            height: auto; 
            min-height: 297mm; /* A4縦 */
            position: relative;
            box-sizing: border-box;
            padding: 15mm; /* 余白 */
            page-break-after: always;
            break-after: always;
            overflow: visible;
          }
          .print-sheet:last-child {
            page-break-after: auto;
            break-after: auto;
          }
          .print-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; 
            height: 100%;
            pointer-events: none;
            z-index: 10;
          }
          /* 改ページ制御 */
          .ws-box, .ws-lines, table, tr, .ws-header, h1 {
            break-inside: avoid;
          }
          /* 背景色強制 */
          * { -webkit-print-color-adjust: exact; print-color-adjust: exact; }
          /* スタンプの見た目 */
          .eval-btn:not(.active) { opacity: 0.1; border-color: #eee; }
          /* 不要なUI非表示 */
          .btn, button, .no-print { display: none !important; }
        }
        /* 画面表示用 (プレビュー) */
        .print-sheet {
          border-bottom: 1px dashed #ccc;
          margin-bottom: 20px;
        }
      </style>
    `;

    // 4. コンテンツ構築
    let contentHtml = '';
    pages.forEach(p => {
      contentHtml += `
        <div class="print-sheet">
          <div class="print-content">${p.html}</div>
          ${p.img ? `<img src="${p.img}" class="print-overlay">` : ''}
        </div>
      `;
    });

    // 5. 書き込みと印刷実行
    win.document.write(`
      <!DOCTYPE html>
      <html>
        <head>
          <title>印刷プレビュー</title>
          ${styles}
          ${printCss}
        </head>
        <body class="print-only-container">
          ${contentHtml}
          <script>
            // 画像などの読み込みを待ってから印刷
            window.onload = () => {
              setTimeout(() => {
                window.focus();
                window.print();
                // 印刷ダイアログ終了後に閉じる
                // (ブラウザによっては即座に閉じる場合もあるため、この挙動が最も安全)
                try {
                   // Chrome等ではprintブロック後のコードが即実行されない場合があるため
                   // onafterprintイベントも併用するとより確実ですが、
                   // シンプルにタイムアウトでも多くの場合は機能します。
                   window.close();
                } catch(e) {}
              }, 1000);
            };
          <\/script>
        </body>
      </html>
    `);
    win.document.close();
  }
};

// ==============================================
// Modal Controllers
// ==============================================
const Modals = {
  openSettings: () => new bootstrap.Modal(document.getElementById('settingsModal')).show(),
  openImport: () => new bootstrap.Modal(document.getElementById('importModal')).show(),
  openPdfImport: () => new bootstrap.Modal(document.getElementById('pdfImportModal')).show(),

  openRubric: () => {
    if (!State.currentTask) return Swal.fire('エラー', '授業を選択してください', 'warning');
    const container = document.getElementById('rubricContainer');
    container.innerHTML = State.currentTask.rubricHtml || 
      `<div class="text-center py-5 text-muted">
         <p class="mb-0">「AI作成」ボタンを押して評価基準を作成してください。</p>
       </div>`;
    new bootstrap.Modal(document.getElementById('rubricModal')).show();
  },

  openDashboard: async () => {
    if (!State.currentTask) return Swal.fire('エラー', '授業を選択してください', 'warning');
    
    UI.showLoading("提出状況を取得中...");
    try {
      let subs = await Server.call('getTaskSubmissions', State.currentTask.id);
      if (!subs) subs = [];
      
      State.dashboardData = subs; // メモリに保存
      const grid = document.getElementById('dashboardGrid');
      grid.innerHTML = '';

      if (subs.length === 0) {
        grid.innerHTML = '<div class="col-12 text-center py-5 text-muted">提出された回答はありません</div>';
      } else {
        subs.forEach((s, index) => {
          const col = document.createElement('div');
          col.className = 'col-md-3 col-sm-6';
          
          const statusBadge = s.status === 'graded' 
            ? '<span class="badge bg-primary">添削済</span>' 
            : '<span class="badge bg-success">提出済</span>';
            
          const imgHtml = s.canvasImage 
            ? `<img src="${s.canvasImage}" style="max-height:100%; max-width:100%; object-fit:contain;">`
            : '<span class="text-muted small">No Image</span>';

          col.innerHTML = `
            <div class="card h-100 shadow-sm" style="cursor:pointer;" onclick="App.openGrading(${index})">
              <div class="card-img-top bg-light d-flex align-items-center justify-content-center" style="height:150px; overflow:hidden;">
                ${imgHtml}
              </div>
              <div class="card-body p-2">
                <h6 class="card-title fw-bold mb-1 text-truncate">${s.studentName}</h6>
                <div class="d-flex justify-content-between align-items-center">
                  ${statusBadge}
                  <small class="text-muted" style="font-size:0.7em">${new Date(s.submittedAt).toLocaleTimeString()}</small>
                </div>
              </div>
            </div>`;
          grid.appendChild(col);
        });
      }
      new bootstrap.Modal(document.getElementById('dashboardModal')).show();
    } finally {
      UI.hideLoading();
    }
  }
};

// ==============================================
// Global State Management
// ==============================================
const State = {
  unitData: null,      // 単元計画データ (JSON)
  currentTask: null,   // 現在選択中の授業タスク
  fabricCanvas: null,  // 手書きキャンバスインスタンス
  peerCanvas: null,    // 友達の回答閲覧用キャンバス
  isDrawMode: false,   // 手書きモードフラグ
  ocrCache: "",        // OCR解析結果テキスト
  studentId: null,     // 児童ID (LocalStorage)
  gradingRow: null,    // 添削中の行番号
  dashboardData: [],   // ダッシュボード用データキャッシュ
  isGalleryMode: false,// ギャラリーモードフラグ
  currentPeerResponse: null // 現在閲覧中の友達の回答
};

// ==============================================
// Main Application Logic
// ==============================================
const App = {
  
  // --- Initialization ---
  init: async () => {
    // Student Setup
    if (APP_CONFIG.mode === 'student') {
      State.studentId = localStorage.getItem('manabi_sid');
      if (!State.studentId) {
        State.studentId = 'S_' + Date.now() + Math.random().toString(36).substr(2, 5);
        localStorage.setItem('manabi_sid', State.studentId);
      }
      // Auto-save loop
      setInterval(App.autoSaveLocal, 10000);
    }

    // Global Event Listener for Evaluation Stamps (delegation)
    document.body.addEventListener('click', (e) => {
      const btn = e.target.closest('.eval-btn');
      if (btn) {
        const cell = btn.closest('td');
        if (cell) {
          cell.querySelectorAll('.eval-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
        }
      }
    });

    // View Setup
    if (APP_CONFIG.mode === 'teacher') {
      UI.showLoading("システムを起動しています", "ユーザー設定を確認中...");
      const status = await Server.call('checkSetupStatus');
      if (status.isSetup) {
        document.getElementById('setupWizard').classList.add('d-none');
        document.getElementById('appContainer').classList.remove('d-none');
        App.loadConfig();
        Editor.init();
      } else {
        UI.hideLoading();
        document.getElementById('setupWizard').classList.remove('d-none');
      }
    } else {
      // Student View
      UI.showLoading("ワークシートを準備しています", "課題データをダウンロード中...");
      document.getElementById('appContainer').classList.remove('d-none');
      if (APP_CONFIG.taskId) {
        App.loadFromHistory(APP_CONFIG.taskId);
      } else {
        UI.hideLoading();
        Swal.fire('エラー', '課題IDが無効です。URLを確認してください。', 'error');
      }
    }
  },

  performSetup: async () => {
    UI.showLoading("データベースを構築しています", "初期化処理を実行中...");
    try {
      await Server.call('performInitialSetup');
      location.reload(); // リロードして設定を反映
    } catch (e) {
      console.error(e);
    }
  },

  loadConfig: async () => {
    const config = await Server.call('getUserConfig');
    document.getElementById('apiKeyInput').value = config.apiKey;
    document.getElementById('teacherNameInput').value = config.teacherName;
    UI.hideLoading();
    App.loadHistory();
  },

  saveSettings: async () => {
    await Server.call('saveUserConfig',
      document.getElementById('apiKeyInput').value,
      document.getElementById('teacherNameInput').value
    );
    UI.toast('設定を保存しました');
    bootstrap.Modal.getInstance(document.getElementById('settingsModal')).hide();
  },

  // --- Data Management ---

  processImport: () => {
    try {
      const inputVal = document.getElementById('jsonInput').value;
      const firstBrace = inputVal.indexOf('{');
      const lastBrace = inputVal.lastIndexOf('}');
      if (firstBrace === -1 || lastBrace === -1) throw new Error("有効なJSONデータが見つかりません。");
      
      const jsonString = inputVal.substring(firstBrace, lastBrace + 1);
      const json = JSON.parse(jsonString);

      if (!json.tasks || !Array.isArray(json.tasks)) throw new Error("JSONデータに 'tasks' 配列が含まれていません。");

      State.unitData = json;
      App.renderTaskList();
      bootstrap.Modal.getInstance(document.getElementById('importModal')).hide();
      UI.toast('計画を読み込みました');
    } catch (e) {
      console.error(e);
      Swal.fire({icon: 'error', title: 'JSON読み込みエラー', text: e.message});
    }
  },

  loadSampleJson: () => {
    const sample = {
      "unitInfo": { "subject": "国語", "grade": 5, "unitName": "注文の多い料理店" },
      "tasks": [
        { "id": "t1", "category": "つかむ", "title": "導入: 扉の向こうへ", "description": "物語の入り口を読む" },
        { "id": "t2", "category": "まなぶ", "title": "色と音の表現", "description": "宮沢賢治の表現技法を探す" }
      ]
    };
    document.getElementById('jsonInput').value = JSON.stringify(sample, null, 2);
  },

  renderTaskList: () => {
    const list = document.getElementById('taskList');
    list.innerHTML = '';
    
    if (!State.unitData || !State.unitData.tasks) return;
    document.getElementById('taskCount').innerText = State.unitData.tasks.length + '件';
    
    State.unitData.tasks.forEach(task => {
      const div = document.createElement('div');
      div.className = 'list-group-item d-flex p-2 align-items-center';
      div.innerHTML = `
        <div class="me-2">
          <input class="form-check-input task-checkbox" type="checkbox" value="${task.id}" checked>
        </div>
        <button class="btn btn-link text-start text-dark p-0 w-100 text-decoration-none shadow-none" type="button">
          <div class="d-flex justify-content-between align-items-center">
            <small class="badge bg-secondary rounded-pill">${task.category || '学習'}</small>
            <small class="text-muted">${task.step || ''}</small>
          </div>
          <div class="fw-bold text-truncate small mt-1">${task.title || '無題'}</div>
        </button>`;
      
      const btn = div.querySelector('button');
      btn.onclick = () => App.selectTaskById(task.id);
      list.appendChild(div);
    });
  },

  toggleSelectAll: (cb) => {
    document.querySelectorAll('.task-checkbox').forEach(box => box.checked = cb.checked);
  },

  // --- Task Selection & Editor ---

  selectTaskById: (taskId) => {
    const task = State.unitData.tasks.find(t => t.id === taskId);
    if (task) App.selectTask(task);
  },

  selectTask: async (task) => {
    State.currentTask = task;
    
    document.getElementById('emptyState')?.classList.add('d-none');
    document.getElementById('paperArea').classList.remove('d-none');
    document.getElementById('editorToolbar').classList.remove('d-none');
    document.getElementById('currentTaskTitle').innerText = task.title || "無題";
    
    try { App.resetCanvas(); } catch(e) { console.warn(e); }
    
    document.getElementById('worksheetContent').contentEditable = (APP_CONFIG.mode === 'teacher');
    
    UI.showLoading("データを取得中...");
    try {
      const data = await Server.call('loadWorksheetFromDB', task.id);
      
      if (data) {
        document.getElementById('worksheetContent').innerHTML = data.htmlContent;
        State.currentTask.rubricHtml = data.rubricHtml;
        if (data.canvasJson) State.currentTask.canvasData = data.canvasJson;
        
        if (APP_CONFIG.mode === 'student') {
          setTimeout(async () => {
            App.toggleDrawMode(true); 
            await App.loadMyResponse();
          }, 500);
        }
      } else {
        const info = State.unitData?.unitInfo || {};
        document.getElementById('worksheetContent').innerHTML = `
          <div class="d-flex flex-column align-items-center justify-content-center h-100 text-muted" style="min-height: 297mm;">
            <div class="ws-header w-100">
              <div>${info.grade || ''} ${info.unitName || ''}</div>
              <div>名前: __________________</div>
            </div>
            <h1>${task.title}</h1>
            <div class="my-5 text-center">
              <p class="mb-4">この授業のワークシートはまだ作成されていません。</p>
              <button class="btn btn-primary btn-lg rounded-pill px-5 shadow-sm" onclick="App.generateSingleWorksheet()">
                <i class="bi bi-stars"></i> AIで作成する
              </button>
            </div>
          </div>`;
      }
      
      if(APP_CONFIG.mode === 'teacher') Editor.enableResizing();

    } finally {
      UI.hideLoading();
    }
  },

  // --- History Management ---

  loadHistory: async () => {
    const history = await Server.call('getHistory');
    const list = document.getElementById('historyList');
    list.innerHTML = '';
    
    history.forEach(h => {
      const btn = document.createElement('button');
      btn.className = 'list-group-item list-group-item-action small py-2';
      btn.innerHTML = `
        <div class="fw-bold text-truncate">${h.title}</div>
        <small class="text-muted" style="font-size:0.75rem">
          ${new Date(h.timestamp).toLocaleDateString()} ${new Date(h.timestamp).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}
        </small>`;
      btn.onclick = () => App.loadFromHistory(h.id);
      list.appendChild(btn);
    });
  },

  loadFromHistory: async (taskId) => {
    UI.showLoading("履歴を展開中...", "データを復元しています");
    try {
      App.resetCanvas();
      const data = await Server.call('loadWorksheetFromDB', taskId);
      
      if (data) {
        document.getElementById('paperArea').classList.remove('d-none');
        document.getElementById('editorToolbar').classList.remove('d-none');
        document.getElementById('emptyState')?.classList.add('d-none');
        
        document.getElementById('worksheetContent').innerHTML = data.htmlContent;
        document.getElementById('currentTaskTitle').innerText = data.stepTitle;
        document.getElementById('worksheetContent').contentEditable = (APP_CONFIG.mode === 'teacher');

        State.currentTask = {
          id: data.taskId,
          title: data.stepTitle,
          description: "",
          canvasData: data.canvasJson,
          rubricHtml: data.rubricHtml,
          ... (data.jsonSource || {})
        };
        State.currentTask.title = data.stepTitle;

        State.unitData = {
          unitInfo: { unitName: data.unitName || "復元された単元" },
          tasks: [State.currentTask]
        };

        if (APP_CONFIG.mode === 'teacher') App.renderTaskList();
        
        if (APP_CONFIG.mode === 'student') {
          setTimeout(async () => {
            App.toggleDrawMode(true);
            await App.loadMyResponse();
          }, 500);
        }
        
        if(APP_CONFIG.mode === 'teacher') Editor.enableResizing();
        
      } else {
        Swal.fire('エラー', 'データが見つかりません。削除された可能性があります。', 'error');
      }
    } catch (e) {
      console.error(e);
      Swal.fire('読込エラー', '履歴の展開に失敗しました。', 'error');
    } finally {
      UI.hideLoading();
    }
  },

  // --- AI Generation (Preserving Stamps Prompt) ---

  generateSingleWorksheet: async (useOcr = false) => {
    if (!State.currentTask) return;
    UI.showLoading("AIが執筆中です", "レイアウトを構成しています...");
    try {
      let extraContext = "";
      if (useOcr && State.ocrCache) {
        extraContext = `\n【参考資料テキスト】\n${State.ocrCache.substring(0, 1500)}...\n※この資料の内容を授業に反映させてください。`;
      }

      const info = State.unitData?.unitInfo || { grade: "", unitName: "" };
      
      // ★ スタンプ対応のプロンプトを維持
      const prompt = `
        あなたは日本の小学校教師です。以下の授業情報から、児童が取り組むためのワークシートのHTML(body内部のみ)を作成してください。
        
        【授業情報】
        学年: ${info.grade}
        単元名: ${info.unitName}
        授業タイトル: ${State.currentTask.title}
        活動内容: ${State.currentTask.description}
        ${extraContext}
        
        【出力HTMLの構成（厳守）】
        以下のHTML構造をテンプレートとしてそのまま使用し、「3. 本文エリア」の中身のみを活動内容に合わせて記述してください。
        Markdown記法(\`\`\`html)は禁止です。

        <!-- 1. リッチヘッダー -->
        <div class="ws-header" style="display:flex; justify-content:space-between; align-items:end; border-bottom: 3px double #555; padding-bottom: 10px; margin-bottom: 20px; font-family: 'Zen Maru Gothic', sans-serif;">
           <div>
             <span style="background:#333; color:#fff; padding:2px 8px; border-radius:4px; font-size:0.7em; margin-right:5px;">${info.grade}</span>
             <span style="font-weight:bold; color:#333;">${info.unitName}</span>
           </div>
           <div style="text-align:right; font-size:0.9em;">
             <span style="margin-right:15px;">年　組　番</span>
             <span style="font-weight:bold; font-size:1.1em;">名前 __________________</span>
           </div>
        </div>

        <!-- 2. タイトル -->
        <h1 style="text-align:center; font-size:1.8em; margin-bottom:30px; border-bottom:1px solid #ddd; padding-bottom:10px;">${State.currentTask.title}</h1>

        <!-- 3. 本文エリア（ここをAIが生成） -->
        <div style="min-height: 400px;">
          (ここに学習課題・問い・記述欄を生成。クラス名: ws-box, ws-lines, table table-bordered を活用)
        </div>

        <!-- 4. コンパクトフッター（振り返り＆自己評価） -->
        <div style="margin-top: 30px; border-top: 2px dashed #ccc; padding-top: 15px; display: flex; gap: 15px; align-items: start;">
          <div style="flex: 6;">
            <div style="font-weight:bold; font-size:0.9em; margin-bottom:5px; color:#555;">■ ふりかえり</div>
            <div class="ws-lines" style="height: 4.5em; background-image: linear-gradient(#ccc 1px, transparent 1px); background-size: 100% 1.5em; line-height: 1.5em;"></div>
          </div>
          <div style="flex: 4;">
            <div style="font-weight:bold; font-size:0.9em; margin-bottom:5px;">■ 自己評価</div>
            <table class="table table-bordered table-sm mb-0" style="font-size: 0.75em; text-align:center; background:#fff;">
              <tr>
                <td class="bg-light text-start">わかった・できた</td>
                <td style="vertical-align:middle; width:120px;">
                   <span class="eval-btn" data-val="3">◎</span><span class="eval-btn" data-val="2">◯</span><span class="eval-btn" data-val="1">△</span>
                </td>
              </tr>
              <tr>
                <td class="bg-light text-start">考えた・表した</td>
                <td style="vertical-align:middle;">
                   <span class="eval-btn" data-val="3">◎</span><span class="eval-btn" data-val="2">◯</span><span class="eval-btn" data-val="1">△</span>
                </td>
              </tr>
              <tr>
                <td class="bg-light text-start">進んで学んだ</td>
                <td style="vertical-align:middle;">
                   <span class="eval-btn" data-val="3">◎</span><span class="eval-btn" data-val="2">◯</span><span class="eval-btn" data-val="1">△</span>
                </td>
              </tr>
            </table>
          </div>
        </div>

        【配慮】
        低学年の場合は漢字を減らし、平易な表現にしてください。
      `;

      let html = await Server.call('callGeminiAPI', prompt);
      html = App.cleanAIOutput(html);
      
      await Server.call('saveWorksheetToDB', {
        taskId: State.currentTask.id,
        unitName: info.unitName,
        stepTitle: State.currentTask.title,
        htmlContent: html,
        jsonSource: State.currentTask
      });
      
      App.selectTask(State.currentTask);
      
    } catch (e) {
      console.error(e);
      Swal.fire('生成エラー', 'AIによる生成に失敗しました。時間をおいて試してください。', 'error');
    } finally {
      UI.hideLoading();
    }
  },

  cleanAIOutput: (text) => {
    if (!text) return "";
    return text
      .replace(/```html/gi, "")
      .replace(/```/g, "")
      .replace(/^[\s\S]*?<body[^>]*>/i, "")
      .replace(/<\/body>[\s\S]*$/i, "")
      .trim();
  },

  startBatchGeneration: async () => {
    const checkboxes = document.querySelectorAll('.task-checkbox:checked');
    if (checkboxes.length === 0) return Swal.fire('選択なし', '生成するタスクを選択してください', 'info');

    const queue = Array.from(checkboxes).map(cb => State.unitData.tasks.find(t => t.id === cb.value));
    if (!confirm(`${queue.length}件のワークシートを一括生成しますか？`)) return;

    UI.showLoading("一括生成を開始します", "しばらくそのままお待ちください...");
    UI.toggleBatchProgress(true);
    
    const info = State.unitData.unitInfo;

    try {
      for (let i = 0; i < queue.length; i++) {
        const task = queue[i];
        UI.updateBatchProgress(Math.round(((i) / queue.length) * 100), `${i + 1} / ${queue.length}: ${task.title}`);
        
        try {
          const prompt = `
            あなたは小学校教師です。以下の授業情報からワークシートHTMLを作成してください。
            授業情報: 学年:${info.grade}, 単元:${info.unitName}, タイトル:${task.title}, 活動:${task.description}
            
            【出力HTML構成（厳守）】
            <!-- 4. フッター (スタンプ付き) -->
            <div style="margin-top: 30px; border-top: 2px dashed #ccc; padding-top: 15px; display: flex; gap: 15px;">
              <div style="flex: 6;">
                <div style="font-weight:bold; font-size:0.9em; margin-bottom:5px;">■ ふりかえり</div>
                <div class="ws-lines" style="height: 4.5em; background-image: linear-gradient(#ccc 1px, transparent 1px); background-size: 100% 1.5em;"></div>
              </div>
              <div style="flex: 4;">
                <div style="font-weight:bold; font-size:0.9em; margin-bottom:5px;">■ 自己評価</div>
                <table class="table table-bordered table-sm mb-0" style="font-size: 0.75em; text-align:center;">
                  <tr>
                    <td class="bg-light">わかった・できた</td>
                    <td style="width:120px;"><span class="eval-btn" data-val="3">◎</span><span class="eval-btn" data-val="2">◯</span><span class="eval-btn" data-val="1">△</span></td>
                  </tr>
                  <tr>
                    <td class="bg-light">考えた・表した</td>
                    <td><span class="eval-btn" data-val="3">◎</span><span class="eval-btn" data-val="2">◯</span><span class="eval-btn" data-val="1">△</span></td>
                  </tr>
                  <tr>
                    <td class="bg-light">進んで学んだ</td>
                    <td><span class="eval-btn" data-val="3">◎</span><span class="eval-btn" data-val="2">◯</span><span class="eval-btn" data-val="1">△</span></td>
                  </tr>
                </table>
              </div>
            </div>
          `;
          
          let html = await Server.call('callGeminiAPI', prompt);
          html = App.cleanAIOutput(html);
          
          await Server.call('saveWorksheetToDB', {
            taskId: task.id,
            unitName: info.unitName,
            stepTitle: task.title,
            htmlContent: html,
            jsonSource: task
          });
        } catch (e) {
          console.error(`Task ${task.title} failed:`, e);
        }
        await new Promise(r => setTimeout(r, 1500));
      }
      
      UI.updateBatchProgress(100, '完了');
      App.loadHistory();
      UI.toast('一括生成が完了しました');
      
    } finally {
      setTimeout(() => {
        UI.toggleBatchProgress(false);
        UI.hideLoading();
      }, 1000);
    }
  },

  saveCurrentWorksheet: async () => {
    if (!State.currentTask) return;
    UI.showLoading("保存しています", "クラウドに同期中...");
    
    const content = document.getElementById('worksheetContent').innerHTML;
    let canvasJson = null;
    if (State.fabricCanvas) canvasJson = State.fabricCanvas.toJSON();

    const data = {
      taskId: State.currentTask.id,
      unitName: State.unitData?.unitInfo?.unitName,
      stepTitle: State.currentTask.title,
      htmlContent: content,
      jsonSource: State.currentTask,
      canvasJson: canvasJson,
      rubricHtml: State.currentTask.rubricHtml
    };

    try {
      await Server.call('saveWorksheetToDB', data);
      UI.toast("保存しました");
      if (APP_CONFIG.mode === 'teacher') App.loadHistory();
    } finally {
      UI.hideLoading();
    }
  },

  // ★ New Unified Print Methods (Using Printer object)
  printCurrentWorksheet: async () => {
    if (!State.currentTask) return;
    
    // 現在のHTMLコンテンツ
    const html = document.getElementById('worksheetContent').innerHTML;
    
    // 現在の手書きキャンバス画像 (高画質)
    let img = null;
    if (State.fabricCanvas) {
      img = State.fabricCanvas.toDataURL({ format: 'png', multiplier: 2 });
    }
    
    // 統一プリンタへ送信
    Printer.run([{ html, img }]);
  },

  startBatchPrint: async () => {
    const checkboxes = document.querySelectorAll('.task-checkbox:checked');
    if (checkboxes.length === 0) return Swal.fire('選択なし', '印刷するタスクを選択してください', 'info');
    
    const taskIds = Array.from(checkboxes).map(cb => cb.value);
    UI.showLoading("印刷データを準備中...");
    
    try {
      const sheets = await Server.call('getWorksheetsByIds', taskIds);
      
      // データをPrinter用に整形
      const pages = sheets.map(s => ({
        html: s.htmlContent,
        img: null // 一括印刷時は現状手書きデータを含めない（必要ならDBから取得して含める）
      }));
      
      Printer.run(pages);
      
    } finally {
      UI.hideLoading();
    }
  },

  // --- Student & Grading Logic ---
  
  autoSaveLocal: () => {
    if (APP_CONFIG.mode !== 'student' || !State.currentTask || !State.fabricCanvas) return;
    const key = `manabi_${State.currentTask.id}`;
    localStorage.setItem(key, JSON.stringify({ j: State.fabricCanvas.toJSON(), t: Date.now() }));
    const ind = document.getElementById('autoSaveIndicator');
    if(ind) ind.innerHTML = `<i class="bi bi-cloud-check"></i> ${new Date().toLocaleTimeString()}`;
  },

  loadMyResponse: async () => {
    const resp = await Server.call('getMyResponse', State.currentTask.id, State.studentId);
    if (resp) {
      if (resp.canvasJson && State.fabricCanvas) State.fabricCanvas.loadFromJSON(resp.canvasJson);
      const chk = document.getElementById('isPublicCheck');
      if(chk) chk.checked = (resp.isPublic === "" || resp.isPublic === true);
      
      if (resp.feedbackText || resp.status === 'graded') {
        const btn = document.getElementById('btnFeedback');
        if(btn) {
          btn.classList.remove('d-none');
          btn.onclick = () => Swal.fire({ title: '先生からのコメント', text: resp.feedbackText || "（コメントなし）", icon: 'info' });
          UI.toast("添削が届いています");
        }
      }
    } else {
      const local = localStorage.getItem(`manabi_${State.currentTask.id}`);
      if (local && State.fabricCanvas) {
        State.fabricCanvas.loadFromJSON(JSON.parse(local).j);
        UI.toast("下書きを復元しました");
      }
    }
  },

  submitStudentResponse: async (status) => {
    const name = document.getElementById('studentNameInput').value;
    const isPublic = document.getElementById('isPublicCheck').checked;
    
    if (!name && status === 'submitted') return Swal.fire('名前を入力してください', '', 'warning');
    
    UI.showLoading(status === 'draft' ? "一時保存中..." : "提出しています", "先生にデータを送信中...");
    try {
      let img = "";
      if (State.fabricCanvas) img = State.fabricCanvas.toDataURL({ format: 'png', multiplier: 0.5 });
      
      // ★ 自己評価の結果をテキスト化して収集 (スタンプロジック維持)
      let evalText = "";
      const rows = document.querySelectorAll('#worksheetContent table tr');
      rows.forEach(r => {
        const label = r.querySelector('td:first-child')?.innerText;
        const activeBtn = r.querySelector('.eval-btn.active');
        if(label && activeBtn) {
           evalText += `[${label}: ${activeBtn.innerText}] `;
        }
      });

      await Server.call('saveStudentResponse', {
        taskId: State.currentTask.id,
        studentId: State.studentId,
        studentName: name || "名無し",
        canvasImage: img,
        canvasJson: JSON.stringify(State.fabricCanvas?.toJSON()),
        textContent: evalText,
        status: status,
        isPublic: isPublic
      });
      
      if (status === 'submitted') localStorage.removeItem(`manabi_${State.currentTask.id}`);
      UI.toast(status === 'draft' ? "保存しました" : "提出しました！");
    } finally {
      UI.hideLoading();
    }
  },

  // --- Plaza (Gallery) Split View Logic ---

  toggleGalleryMode: async (show) => {
    State.isGalleryMode = show;
    const workspace = document.getElementById('workspaceContainer');
    const plaza = document.getElementById('plazaPanel');
    const btnWork = document.getElementById('btnModeWork');
    const btnPlaza = document.getElementById('btnModePlaza');
    
    if (show) {
      btnWork.classList.replace('btn-primary', 'btn-light');
      btnPlaza.classList.replace('btn-light', 'btn-primary');
      workspace.classList.add('scale-down-mode');
      plaza.classList.remove('d-none');
      await App.loadPlazaItems();
    } else {
      btnWork.classList.replace('btn-light', 'btn-primary');
      btnPlaza.classList.replace('btn-primary', 'btn-light');
      workspace.classList.remove('scale-down-mode');
      plaza.classList.add('d-none');
    }
  },

  loadPlazaItems: async () => {
    const grid = document.getElementById('plazaGrid');
    grid.innerHTML = '<div class="text-center w-100 py-5"><div class="spinner-border text-primary"></div></div>';
    try {
      const items = await Server.call('getSharedResponses', State.currentTask.id);
      grid.innerHTML = '';
      if (!items || items.length === 0) {
        grid.innerHTML = '<div class="col-12 text-center py-5 text-muted">まだ誰も提出していません</div>';
      } else {
        items.forEach(i => {
          if(i.studentId === State.studentId) return;
          const col = document.createElement('div');
          col.className = 'col-6';
          col.innerHTML = `
            <div class="card h-100 shadow-sm border-0" style="cursor:pointer; transition:transform 0.2s;" onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">
              <div class="bg-light d-flex align-items-center justify-content-center overflow-hidden position-relative" style="aspect-ratio: 210/297;">
                <img src="${i.canvasImage}" class="img-fluid" style="object-fit:contain;">
              </div>
              <div class="card-footer bg-white border-top-0 py-1 px-2 text-center">
                <small class="fw-bold text-truncate d-block">${i.studentName}</small>
              </div>
            </div>`;
          col.onclick = () => App.openPlazaDetail(i);
          grid.appendChild(col);
        });
      }
    } catch(e) { grid.innerHTML = 'Error'; }
  },

  openPlazaDetail: (item) => {
    State.currentPeerResponse = item;
    if(!Array.isArray(item.reactions)) item.reactions = [];
    document.getElementById('plazaGrid').classList.add('d-none');
    document.getElementById('plazaDetail').classList.remove('d-none');
    document.getElementById('plazaDetail').classList.add('d-flex');
    document.getElementById('plazaDetailName').innerText = `${item.studentName} さんの作品`;
    const myContent = document.getElementById('worksheetContent').innerHTML;
    document.getElementById('plazaPeerContent').innerHTML = myContent;
    const cvEl = document.getElementById('plazaPeerCanvas');
    cvEl.width = 794; cvEl.height = 1123; 
    if(State.peerCanvas) State.peerCanvas.dispose();
    State.peerCanvas = new fabric.Canvas('plazaPeerCanvas', { selection: false });
    if(item.canvasJson) {
      State.peerCanvas.loadFromJSON(item.canvasJson, () => {
         State.peerCanvas.forEachObject(o => o.selectable = false);
         State.peerCanvas.renderAll();
      });
    }
    App.renderPeerReactions(item.reactions);
  },

  closePlazaDetail: () => {
    document.getElementById('plazaDetail').classList.add('d-none');
    document.getElementById('plazaDetail').classList.remove('d-flex');
    document.getElementById('plazaGrid').classList.remove('d-none');
    State.currentPeerResponse = null;
  },

  sendReaction: async (type, value) => {
    if(!State.currentPeerResponse) return;
    if(!Array.isArray(State.currentPeerResponse.reactions)) State.currentPeerResponse.reactions = [];
    const commentInput = document.getElementById('reactionComment');
    const val = type === 'comment' ? commentInput.value : value;
    if(!val) return;
    const tempReaction = { type, value: val, fromName: document.getElementById('studentNameInput').value || '自分' };
    State.currentPeerResponse.reactions.push(tempReaction);
    App.renderPeerReactions(State.currentPeerResponse.reactions);
    if(type === 'comment') commentInput.value = '';
    await Server.call('savePeerReaction', {
      taskId: State.currentTask.id,
      targetResponseId: State.currentPeerResponse.responseId,
      reaction: tempReaction
    });
    UI.toast('送りました！');
  },

  renderPeerReactions: (list) => {
    const div = document.getElementById('peerReactionsList');
    div.innerHTML = '';
    if(!Array.isArray(list) || list.length === 0) return;
    list.slice(-5).forEach(r => {
      const d = document.createElement('div');
      d.className = 'border-bottom py-1';
      d.innerHTML = `<span class="fw-bold me-2">${r.fromName}</span> ${r.value}`;
      div.appendChild(d);
    });
  },

  // --- Teacher Grading ---
  openGrading: (index) => {
    const s = State.dashboardData[index];
    State.gradingRow = s.rowIndex;
    bootstrap.Modal.getInstance(document.getElementById('dashboardModal')).hide();
    const container = document.getElementById('gradingContainer');
    container.innerHTML = `<div id="gradingPaper" class="sheet shadow-sm"><div class="p-5">${document.getElementById('worksheetContent').innerHTML}</div></div><canvas id="gradingCanvas"></canvas>`;
    new bootstrap.Modal(document.getElementById('gradingModal')).show();
    setTimeout(() => {
      const paper = document.getElementById('gradingPaper');
      const cv = document.getElementById('gradingCanvas');
      cv.width = paper.offsetWidth;
      cv.height = paper.offsetHeight;
      cv.style.position = 'absolute';
      cv.style.top = paper.offsetTop + 'px';
      cv.style.left = paper.offsetLeft + 'px';
      cv.style.zIndex = 99;
      const gCanvas = new fabric.Canvas('gradingCanvas', { isDrawingMode: true });
      gCanvas.freeDrawingBrush.width = 3;
      gCanvas.freeDrawingBrush.color = "red";
      if (s.canvasJson) gCanvas.loadFromJSON(s.canvasJson);
      State.gradingCanvas = gCanvas;
      document.getElementById('gradingTitle').innerText = `${s.studentName} さんの回答`;
      document.getElementById('feedbackTextInput').value = s.feedbackText || "";
    }, 500);
  },

  saveGrading: async () => {
    if (!State.gradingRow) return;
    UI.showLoading("返却しています", "コメントと添削内容を保存中...");
    try {
      await Server.call('saveFeedback', {
        rowIndex: State.gradingRow,
        feedbackText: document.getElementById('feedbackTextInput').value,
        canvasJson: JSON.stringify(State.gradingCanvas.toJSON())
      });
      bootstrap.Modal.getInstance(document.getElementById('gradingModal')).hide();
      UI.toast("返却しました");
    } finally {
      UI.hideLoading();
    }
  },

  // --- Other Utils ---
  generateRubric: async () => {
    UI.showLoading("ルーブリック作成中...");
    try {
      let h = await Server.call('generateRubricAI', {
        unitName: "",
        stepTitle: State.currentTask.title,
        description: State.currentTask.description
      });
      h = App.cleanAIOutput(h);
      document.getElementById('rubricContainer').innerHTML = h;
    } finally {
      UI.hideLoading();
    }
  },

  saveRubric: () => {
    State.currentTask.rubricHtml = document.getElementById('rubricContainer').innerHTML;
    App.saveCurrentWorksheet();
    bootstrap.Modal.getInstance(document.getElementById('rubricModal')).hide();
  },

  showShareUrl: async () => {
    if (!State.currentTask) return;
    const url = await Server.call('getWebAppUrl');
    const shareUrl = `${url}?mode=student&taskId=${State.currentTask.id}`;
    document.getElementById('shareUrlInput').value = shareUrl;
    new bootstrap.Modal(document.getElementById('shareModal')).show();
  },

  processOcrImport: async () => { /* OCR placeholder */ },

  initFabric: () => {
    if (!State.fabricCanvas) {
      const c = document.getElementById('drawCanvas');
      if (c) State.fabricCanvas = new fabric.Canvas('drawCanvas', { isDrawingMode: false });
    }
  },

  resetCanvas: () => {
    if (State.fabricCanvas) {
      try { State.fabricCanvas.clear(); State.fabricCanvas.dispose(); } catch(e){}
      State.fabricCanvas = null;
    }
    const cv = document.getElementById('drawCanvas');
    if (cv) cv.classList.add('d-none');
    App.toggleDrawMode(false);
  },

  toggleDrawMode: (forceState) => {
    const newState = (forceState !== undefined) ? forceState : !State.isDrawMode;
    State.isDrawMode = newState;
    const btn = document.getElementById('btnDrawMode');
    const tools = document.getElementById('drawTools');
    const cv = document.getElementById('drawCanvas');
    const pp = document.getElementById('paperArea');
    if(btn) btn.classList.replace(newState ? 'btn-outline-dark' : 'btn-dark', newState ? 'btn-dark' : 'btn-outline-dark');
    if(tools) newState ? tools.classList.remove('d-none') : tools.classList.add('d-none');
    if (newState) {
      if(cv) {
        cv.classList.remove('d-none');
        cv.style.position = 'absolute'; cv.style.left = '0'; cv.style.top = '0';
        if(pp) { cv.width = pp.offsetWidth; cv.height = pp.offsetHeight; }
      }
      if (!State.fabricCanvas && cv) {
        try { State.fabricCanvas = new fabric.Canvas('drawCanvas', { isDrawingMode: true, freeDrawingBrush: { width: 3, color: '#ff0000' } }); } catch(e){}
      } else if (State.fabricCanvas) {
        State.fabricCanvas.isDrawingMode = true;
      }
      if (State.currentTask?.canvasData && State.fabricCanvas) {
        try { State.fabricCanvas.loadFromJSON(State.currentTask.canvasData); } catch(e){}
      }
      document.getElementById('worksheetContent').contentEditable = false;
    } else {
      if (State.fabricCanvas) State.fabricCanvas.isDrawingMode = false;
      const cnt = document.querySelector('.canvas-container');
      if(cnt) cnt.style.pointerEvents = 'none';
      document.getElementById('worksheetContent').contentEditable = (APP_CONFIG.mode === 'teacher');
    }
  },

  updateBrush: () => { if (State.fabricCanvas) State.fabricCanvas.freeDrawingBrush.color = document.getElementById('penColor').value; },
  clearCanvas: () => { if (State.fabricCanvas) State.fabricCanvas.clear(); },
  insertImage: (input) => {
    if(input.files && input.files[0]){
      const r = new FileReader();
      r.onload = e => {
        const i = new Image();
        i.onload = () => {
          const c = document.createElement('canvas'), x = c.getContext('2d'), M = 800;
          let w=i.width, h=i.height;
          if(w>h){if(w>M){h*=M/w;w=M}}else{if(h>M){w*=M/h;h=M}}
          c.width=w; c.height=h; x.drawImage(i,0,0,w,h);
          const u = c.toDataURL('image/jpeg', 0.7);
          
          if(State.isDrawMode && State.fabricCanvas) {
            fabric.Image.fromURL(u, o => {
              o.scaleToWidth(300);
              State.fabricCanvas.add(o);
              State.fabricCanvas.centerObject(o);
            });
          } else {
            App.insertAtCursor(`<img src="${u}" style="max-width:100%; border:1px solid #ccc; display:block; margin:10px auto;">`);
          }
        };
        i.src = e.target.result;
      };
      r.readAsDataURL(input.files[0]);
    }
    input.value = '';
  },
  insertAtCursor: (html) => {
    const e = document.getElementById('worksheetContent');
    e.focus();
    const s = window.getSelection();
    if(s.getRangeAt && s.rangeCount) {
      const r = s.getRangeAt(0);
      if(e.contains(r.commonAncestorContainer)) {
        r.deleteContents();
        const d = document.createElement("div");
        d.innerHTML = html;
        const f = document.createDocumentFragment();
        let n;
        while((n=d.firstChild)) f.appendChild(n);
        r.insertNode(f);
        return;
      }
    }
    e.insertAdjacentHTML('beforeend', html);
  }
};

// ==============================================
// Rich Editor Module (Context Menu & Resizing)
// ==============================================
const Editor = {
  currentTarget: null,

  init: () => {
    const menu = document.createElement('div');
    menu.id = 'ctxMenu';
    menu.className = 'dropdown-menu shadow';
    menu.style.position = 'fixed';
    menu.style.display = 'none';
    menu.style.zIndex = '9999';
    document.body.appendChild(menu);

    document.addEventListener('contextmenu', (e) => {
      const ws = document.getElementById('worksheetContent');
      if (!ws || !ws.contains(e.target)) return;
      // Teacher mode check
      if(document.getElementById('worksheetContent').contentEditable !== "true") return;

      e.preventDefault();
      Editor.showContextMenu(e, menu);
    });

    document.addEventListener('click', () => menu.style.display = 'none');
    Editor.enableResizing();
  },

  enableResizing: () => {
    const oldStyle = document.getElementById('editor-style');
    if(oldStyle) oldStyle.remove();

    const style = document.createElement('style');
    style.id = 'editor-style';
    style.innerHTML = `
      .ws-box, .ws-lines { 
        resize: vertical; 
        overflow: hidden;
        position: relative;
        min-height: 50px;
      }
      @media print { .ws-box, .ws-lines { resize: none; overflow: visible; } }
      
      #worksheetContent[contenteditable="true"] .ws-box:hover,
      #worksheetContent[contenteditable="true"] .ws-lines:hover,
      #worksheetContent[contenteditable="true"] table:hover {
        outline: 2px dashed #a2d2ff;
        cursor: text;
      }
    `;
    document.head.appendChild(style);
  },

  showContextMenu: (e, menu) => {
    const t = e.target;
    let items = [];
    Editor.currentTarget = t;

    const td = t.closest('td, th');
    if (td) {
      items = [
        { label: '<i class="bi bi-arrow-bar-up"></i> 行を上に追加', action: () => Editor.tableAction('addRowUp', td) },
        { label: '<i class="bi bi-arrow-bar-down"></i> 行を下に追加', action: () => Editor.tableAction('addRowDown', td) },
        { divider: true },
        { label: '<i class="bi bi-arrow-bar-left"></i> 列を左に追加', action: () => Editor.tableAction('addColLeft', td) },
        { label: '<i class="bi bi-arrow-bar-right"></i> 列を右に追加', action: () => Editor.tableAction('addColRight', td) },
        { divider: true },
        { label: '<i class="bi bi-trash"></i> 行を削除', action: () => Editor.tableAction('delRow', td) },
        { label: '<i class="bi bi-trash"></i> 列を削除', action: () => Editor.tableAction('delCol', td) }
      ];
    } else if (t.classList.contains('ws-box') || t.classList.contains('ws-lines')) {
      items = [
        { label: '<i class="bi bi-files"></i> ボックスを複製', action: () => Editor.cloneElement(t) },
        { label: '<i class="bi bi-trash"></i> 削除', action: () => t.remove() }
      ];
    } else {
      items = [
        { label: '<i class="bi bi-type-bold"></i> 太字', action: () => document.execCommand('bold') },
        { label: '<i class="bi bi-trash"></i> 削除', action: () => t.remove() }
      ];
    }

    if (items.length === 0) return;

    menu.innerHTML = '';
    items.forEach(i => {
      if (i.divider) {
        menu.innerHTML += '<div class="dropdown-divider"></div>';
      } else {
        const a = document.createElement('a');
        a.className = 'dropdown-item';
        a.href = '#';
        a.innerHTML = i.label;
        a.onclick = (ev) => { ev.preventDefault(); i.action(); };
        menu.appendChild(a);
      }
    });

    menu.style.left = `${e.pageX}px`;
    menu.style.top = `${e.pageY}px`;
    menu.style.display = 'block';
  },

  tableAction: (type, cell) => {
    const row = cell.parentElement;
    const table = row.parentElement.parentElement;
    const rowIndex = row.rowIndex;
    const colIndex = cell.cellIndex;

    switch(type) {
      case 'addRowUp': table.insertRow(rowIndex); break;
      case 'addRowDown': table.insertRow(rowIndex + 1); break;
      case 'delRow': table.deleteRow(rowIndex); break;
      case 'addColLeft': for (let r of table.rows) r.insertCell(colIndex); break;
      case 'addColRight': for (let r of table.rows) r.insertCell(colIndex + 1); break;
      case 'delCol': for (let r of table.rows) r.deleteCell(colIndex); break;
    }
  },

  cloneElement: (el) => {
    const clone = el.cloneNode(true);
    el.after(clone);
  }
};

document.addEventListener('DOMContentLoaded', App.init);
</script>
