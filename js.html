<script>
/**
 * みらいパスポート v2.2.0
 * Update: Phase 3/4 Real-time Sync with Mirai Compass
 * Update: Enhanced Worksheet Wizard (Shared DB Import)
 * Update: Student Status Toolbar (SOS/Focus) & Auto-Save
 * Keeps all previous features (Printer, Plaza, Edit Lock) intact.
 */

// ==============================================
// Server Communication Wrapper
// ==============================================
const Server = {
  call: (funcName, ...args) => {
    return new Promise((resolve, reject) => {
      google.script.run
        .withSuccessHandler(resolve)
        .withFailureHandler((error) => {
          UI.hideLoading();
          console.error(`Server Error [${funcName}]:`, error);
          Swal.fire('通信エラー', error.message || '予期せぬエラーが発生しました', 'error');
          reject(error);
        })
        [funcName](...args);
    });
  }
};

// ==============================================
// UI Utilities
// ==============================================
const UI = {
  showLoading: (mainText, subText = "しばらくお待ちください") => {
    const txt = document.getElementById('loadingText');
    const sub = document.getElementById('loadingSubText');
    if (txt) txt.innerText = mainText;
    if (sub) sub.innerText = subText;
    const overlay = document.getElementById('loadingOverlay');
    if (overlay) overlay.classList.remove('d-none');
  },

  hideLoading: () => {
    const overlay = document.getElementById('loadingOverlay');
    if (overlay) overlay.classList.add('d-none');
  },

  toast: (title, icon = 'success') => {
    Swal.mixin({
      toast: true,
      position: 'top-end',
      showConfirmButton: false,
      timer: 2000
    }).fire({ icon, title });
  },

  updateBatchProgress: (percent, text) => {
    const bar = document.getElementById('batchProgressBar');
    const txt = document.getElementById('batchProgressText');
    if (bar) bar.style.width = `${percent}%`;
    if (txt) txt.innerText = text;
  },

  toggleBatchProgress: (show) => {
    const el = document.getElementById('batchProgressContainer');
    if (el) show ? el.classList.remove('d-none') : el.classList.add('d-none');
  }
};

// ==============================================
// ★ Unified Print System
// ==============================================
const Printer = {
  run: (pages) => {
    if (!pages || pages.length === 0) return;

    const win = window.open('', '_blank');
    if (!win) {
      return Swal.fire('エラー', 'ポップアップがブロックされました。許可してください。', 'error');
    }

    const styles = Array.from(document.querySelectorAll('link[rel="stylesheet"], style'))
      .map(el => el.outerHTML)
      .join('');

    const printCss = `
      <style>
        body { 
          margin: 0; padding: 0; background: white; 
          font-family: "Zen Maru Gothic", sans-serif;
        }
        @media print {
          @page { margin: 0; size: A4; }
          body { margin: 0; padding: 0; }
          .print-sheet {
            width: 100%;
            height: auto; 
            min-height: 297mm;
            position: relative;
            box-sizing: border-box;
            padding: 15mm;
            page-break-after: always;
            break-after: always;
            overflow: visible;
          }
          .print-sheet:last-child {
            page-break-after: auto;
            break-after: auto;
          }
          .print-overlay {
            position: absolute;
            top: 0; left: 0;
            width: 100%; 
            height: 100%;
            pointer-events: none;
            z-index: 10;
          }
          .ws-box, .ws-lines, table, tr, .ws-header, h1 {
            break-inside: avoid;
          }
          * { -webkit-print-color-adjust: exact; print-color-adjust: exact; }
          .eval-btn:not(.active) { opacity: 0.1; border-color: #eee; }
          .btn, button, .no-print { display: none !important; }
        }
        .print-sheet {
          border-bottom: 1px dashed #ccc;
          margin-bottom: 20px;
        }
      </style>
    `;

    let contentHtml = '';
    pages.forEach(p => {
      contentHtml += `
        <div class="print-sheet">
          <div class="print-content">${p.html}</div>
          ${p.img ? `<img src="${p.img}" class="print-overlay">` : ''}
        </div>
      `;
    });

    win.document.write(`
      <!DOCTYPE html>
      <html>
        <head>
          <title>印刷プレビュー</title>
          ${styles}
          ${printCss}
        </head>
        <body class="print-only-container">
          ${contentHtml}
          <script>
            window.onload = () => {
              setTimeout(() => {
                window.focus();
                window.print();
                try { window.close(); } catch(e) {}
              }, 1000);
            };
          <\/script>
        </body>
      </html>
    `);
    win.document.close();
  }
};

// ==============================================
// Modals & Dashboard
// ==============================================
const Modals = {
  openSettings: () => new bootstrap.Modal(document.getElementById('settingsModal')).show(),
  openImport: () => new bootstrap.Modal(document.getElementById('importModal')).show(),
  openPdfImport: () => new bootstrap.Modal(document.getElementById('pdfImportModal')).show(),

  openRubric: () => {
    if (!State.currentTask) return Swal.fire('エラー', '授業を選択してください', 'warning');
    const container = document.getElementById('rubricContainer');
    container.innerHTML = State.currentTask.rubricHtml || 
      `<div class="text-center py-5 text-muted"><p class="mb-0">「AI作成」ボタンを押して評価基準を作成してください。</p></div>`;
    new bootstrap.Modal(document.getElementById('rubricModal')).show();
  },

  openDashboard: async () => {
    if (!State.currentTask) return Swal.fire('エラー', '授業を選択してください', 'warning');
    
    UI.showLoading("提出状況を取得中...");
    try {
      let subs = await Server.call('getTaskSubmissions', State.currentTask.id);
      if (!subs) subs = [];
      
      State.dashboardData = subs;
      const grid = document.getElementById('dashboardGrid');
      grid.innerHTML = '';

      if (subs.length === 0) {
        grid.innerHTML = '<div class="col-12 text-center py-5 text-muted">提出された回答はありません</div>';
      } else {
        subs.forEach((s, index) => {
          const col = document.createElement('div');
          col.className = 'col-md-3 col-sm-6';
          
          const statusBadge = s.status === 'graded' 
            ? '<span class="badge bg-primary">添削済</span>' 
            : '<span class="badge bg-success">提出済</span>';
            
          const imgHtml = s.canvasImage 
            ? `<img src="${s.canvasImage}" style="max-height:100%; max-width:100%; object-fit:contain;">`
            : '<span class="text-muted small">No Image</span>';

          col.innerHTML = `
            <div class="card h-100 shadow-sm" style="cursor:pointer;" onclick="App.openGrading(${index})">
              <div class="card-img-top bg-light d-flex align-items-center justify-content-center" style="height:150px; overflow:hidden;">
                ${imgHtml}
              </div>
              <div class="card-body p-2">
                <h6 class="card-title fw-bold mb-1 text-truncate">${s.studentName}</h6>
                <div class="d-flex justify-content-between align-items-center">
                  ${statusBadge}
                  <small class="text-muted" style="font-size:0.7em">${new Date(s.submittedAt).toLocaleTimeString()}</small>
                </div>
              </div>
            </div>`;
          grid.appendChild(col);
        });
      }
      new bootstrap.Modal(document.getElementById('dashboardModal')).show();
    } finally {
      UI.hideLoading();
    }
  }
};

// ==============================================
// Global State Management
// ==============================================
const State = {
  unitData: null,
  currentTask: null,
  fabricCanvas: null,
  peerCanvas: null,
  isDrawMode: false,
  ocrCache: "",
  studentId: null,
  gradingRow: null,
  dashboardData: [],
  isGalleryMode: false,
  currentPeerResponse: null
};

// ==============================================
// Main Application Logic
// ==============================================
const App = {
  
  // --- Initialization ---
  init: async () => {
    // URLパラメータの解析（APP_CONFIGより優先）
    const params = new URLSearchParams(window.location.search);
    const mode = params.get('mode') || (typeof APP_CONFIG !== 'undefined' ? APP_CONFIG.mode : 'teacher');
    const taskId = params.get('taskId') || (typeof APP_CONFIG !== 'undefined' ? APP_CONFIG.taskId : '');
    const studentId = params.get('studentId') || (typeof APP_CONFIG !== 'undefined' ? APP_CONFIG.studentId : '');
    const studentName = params.get('studentName') || (typeof APP_CONFIG !== 'undefined' ? APP_CONFIG.studentName : '');
    const importId = params.get('importId'); // Compassからの連携ID

    // Student Mode
    if (mode === 'student') {
      // 1. Compass連携情報があれば保存
      if (studentId && studentName) {
        State.studentId = studentId;
        localStorage.setItem('manabi_sid', studentId);
        // 入力欄があれば自動入力
        const nameInput = document.getElementById('studentNameInput');
        if (nameInput) nameInput.value = studentName;
      } else {
        // 通常起動: LocalStorageから復元
        State.studentId = localStorage.getItem('manabi_sid');
        if (!State.studentId) {
          State.studentId = 'S_' + Date.now() + Math.random().toString(36).substr(2, 5);
          localStorage.setItem('manabi_sid', State.studentId);
        }
      }
      
      // Auto-save loop (自動保存)
      setInterval(App.autoSaveLocal, 10000);

      // Student View Setup
      UI.showLoading("ワークシートを準備しています", "課題データをダウンロード中...");
      document.getElementById('appContainer').classList.remove('d-none');
      
      if (taskId) {
        // 設定読み込み後に履歴ロード
        await App.loadConfig(); // config (Compass URL) is needed for sync
        App.loadFromHistory(taskId);
      } else {
        UI.hideLoading();
        Swal.fire('エラー', '課題IDが無効です。URLを確認してください。', 'error');
      }
    } 
    // Teacher Mode
    else {
      UI.showLoading("システムを起動しています", "ユーザー設定を確認中...");
      const status = await Server.call('checkSetupStatus');
      if (status.isSetup) {
        document.getElementById('setupWizard').classList.add('d-none');
        document.getElementById('appContainer').classList.remove('d-none');
        await App.loadConfig();
        Editor.init();
        
        // [New] Compass連携: インポートウィザードのチェック
        if (importId) {
          App.startImportWizard(importId);
        } else {
          // Legacy: Check for taskIds param
          setTimeout(App.checkAutoGenerate, 800);
        }
      } else {
        UI.hideLoading();
        document.getElementById('setupWizard').classList.remove('d-none');
      }
    }

    // Event Listener for Stamps
    document.body.addEventListener('click', (e) => {
      const btn = e.target.closest('.eval-btn');
      if (btn) {
        const cell = btn.closest('td');
        if (cell) {
          cell.querySelectorAll('.eval-btn').forEach(b => b.classList.remove('active'));
          btn.classList.add('active');
        }
      }
    });
  },

  performSetup: async () => {
    UI.showLoading("データベースを構築しています", "初期化処理を実行中...");
    try {
      await Server.call('performInitialSetup');
      location.reload();
    } catch (e) {
      console.error(e);
    }
  },

  loadConfig: async () => {
    const config = await Server.call('getUserConfig');
    if(document.getElementById('apiKeyInput')) document.getElementById('apiKeyInput').value = config.apiKey;
    if(document.getElementById('teacherNameInput')) document.getElementById('teacherNameInput').value = config.teacherName;
    if(document.getElementById('compassUrlInput')) document.getElementById('compassUrlInput').value = config.compassUrl || '';
    
    // Configをグローバルに保持（Sync用）
    App.config = config; 
    
    // Only hide loading in Teacher mode if not loading history immediately
    if (typeof APP_CONFIG !== 'undefined' && APP_CONFIG.mode === 'teacher' && !window.location.search.includes('importId')) {
        UI.hideLoading();
        App.loadHistory();
    }
  },

  saveSettings: async () => {
    await Server.call('saveUserConfig',
      document.getElementById('apiKeyInput').value,
      document.getElementById('teacherNameInput').value,
      document.getElementById('compassUrlInput')?.value || ''
    );
    UI.toast('設定を保存しました');
    bootstrap.Modal.getInstance(document.getElementById('settingsModal')).hide();
    App.loadConfig(); // Reload config
  },

  // --- Compass Integration (Sync) ---

  // コンパスへ通知を送る (Fire-and-forget)
  notifyCompass: async (action, data = {}) => {
    if (!App.config || !App.config.compassUrl || !State.studentId) return;
    
    // URL paramsからmodeを取得 (APP_CONFIGが未定義の場合の対策)
    const params = new URLSearchParams(window.location.search);
    const mode = params.get('mode') || (typeof APP_CONFIG !== 'undefined' ? APP_CONFIG.mode : 'teacher');
    
    if (mode !== 'student') return;

    const nameInput = document.getElementById('studentNameInput');
    const studentName = nameInput ? nameInput.value : '';

    const payload = {
      action: action,
      studentId: State.studentId,
      studentName: studentName,
      taskId: State.currentTask?.id,
      taskTitle: State.currentTask?.title,
      timestamp: new Date().getTime(),
      ...data
    };

    // サーバー経由で送信
    Server.call('syncToCompass', payload).then(res => {
      if(!res.success) console.warn("Sync Warning:", res.error);
    }).catch(e => console.error("Sync Failed:", e));
  },

  // 生徒ステータスの変更
  setStudentStatus: (mode) => {
    App.notifyCompass('syncStatus', { mode: mode, status: 'working' });
    const msg = mode === 'sos' ? 'SOSを発信しました' : (mode === 'focus' ? '集中モードを開始しました' : 'ステータスを解除しました');
    const icon = mode === 'sos' ? 'warning' : 'info';
    UI.toast(msg, icon);
  },

  // 生徒用ツールバーの描画 (HTML構造に依存せず注入)
  renderStudentToolbar: () => {
    const container = document.getElementById('paperArea');
    if (!container) return;

    // 既存ツールバーがあれば削除
    const existing = document.getElementById('student-toolbar');
    if (existing) existing.remove();

    const toolbar = document.createElement('div');
    toolbar.id = 'student-toolbar';
    toolbar.className = 'd-flex justify-content-between align-items-center mb-3 bg-white p-2 rounded shadow-sm sticky-top';
    toolbar.style.top = '10px';
    toolbar.style.zIndex = '1000';
    
    toolbar.innerHTML = `
      <div class="fw-bold text-primary px-2"><i class="bi bi-pencil-square me-2"></i>${State.currentTask?.title || 'ワークシート'}</div>
      <div class="d-flex gap-2">
        <button class="btn btn-outline-danger rounded-pill px-3 btn-sm fw-bold" onclick="App.setStudentStatus('sos')"><i class="bi bi-exclamation-circle-fill me-1"></i>SOS</button>
        <button class="btn btn-outline-info rounded-pill px-3 btn-sm fw-bold" onclick="App.setStudentStatus('focus')"><i class="bi bi-lightning-fill me-1"></i>集中</button>
        <button class="btn btn-success rounded-pill px-4 btn-sm fw-bold shadow-sm" onclick="App.submitStudentResponse('submitted')"><i class="bi bi-send-fill me-1"></i>提出</button>
      </div>
    `;
    
    // コンテナの最上部に挿入
    container.insertBefore(toolbar, container.firstChild);
  },

  // --- Import Wizard (Shared DB) ---

  startImportWizard: async (importId) => {
    UI.showLoading("連携データを確認中...", "単元計画を読み込んでいます");
    try {
      const res = await Server.call('consumeImportQueue', importId);
      if (res.success) {
        // unitDataの構成
        State.unitData = {
          unitInfo: { unitName: res.unitName || "連携単元" },
          tasks: res.taskIds.map(id => ({ id: id, title: "読み込み中..." })) // Placeholder
        };
        
        Swal.fire({
          title: 'ワークシート作成連携',
          text: `みらいコンパスから ${res.taskIds.length} 件の活動データを取り込みました。AIでワークシートを一括作成しますか？`,
          icon: 'question',
          showCancelButton: true,
          confirmButtonText: 'AI作成を開始',
          cancelButtonText: '手動で作成'
        }).then((result) => {
          if (result.isConfirmed) {
            App.startBatchGeneration(res.taskIds);
          } else {
            // リロードして通常画面へ
            window.location.href = window.location.pathname + "?mode=teacher";
          }
        });
      } else {
        Swal.fire('連携エラー', res.message, 'error').then(() => {
           window.location.href = window.location.pathname + "?mode=teacher";
        });
      }
    } catch(e) {
      console.error(e);
      UI.hideLoading();
    }
  },

  // --- Existing Check Logic (Legacy) ---
  checkAutoGenerate: async () => {
    const params = new URLSearchParams(window.location.search);
    const taskIdsStr = params.get('taskIds');
    if (!taskIdsStr) return;
    const taskIds = taskIdsStr.split(',').filter(id => id);
    if (taskIds.length === 0) return;

    UI.showLoading("連携データを確認中...");
    try {
      const sheets = await Server.call('getWorksheetsByIds', taskIds);
      const unfinishedTasks = sheets.filter(s => !s.htmlContent || s.htmlContent.trim() === "");
      
      if (unfinishedTasks.length > 0) {
        if (!State.unitData) {
           State.unitData = {
             unitInfo: { unitName: unfinishedTasks[0].unitName || "連携単元" },
             tasks: unfinishedTasks.map(t => ({ id: t.taskId, title: t.stepTitle, description: "" }))
           };
        }
        Swal.fire({
          title: 'ワークシート作成',
          text: `${unfinishedTasks.length} 件の未作成ワークシートがあります。AIで一括生成しますか？`,
          icon: 'question',
          showCancelButton: true,
          confirmButtonText: '生成を開始',
          cancelButtonText: 'あとで'
        }).then((result) => {
          if (result.isConfirmed) {
            App.startBatchGeneration(unfinishedTasks.map(t => t.taskId));
          } else {
            const newUrl = window.location.pathname + "?mode=teacher";
            window.history.pushState({path:newUrl},'',newUrl);
          }
        });
      }
    } catch(e) { console.error(e); } finally { UI.hideLoading(); }
  },

  // --- Data Management ---

  processImport: () => {
    try {
      const inputVal = document.getElementById('jsonInput').value;
      const firstBrace = inputVal.indexOf('{');
      const lastBrace = inputVal.lastIndexOf('}');
      if (firstBrace === -1 || lastBrace === -1) throw new Error("有効なJSONデータが見つかりません。");
      
      const jsonString = inputVal.substring(firstBrace, lastBrace + 1);
      const json = JSON.parse(jsonString);

      if (!json.tasks || !Array.isArray(json.tasks)) throw new Error("JSONデータに 'tasks' 配列が含まれていません。");

      State.unitData = json;
      App.renderTaskList();
      bootstrap.Modal.getInstance(document.getElementById('importModal')).hide();
      UI.toast('計画を読み込みました');
    } catch (e) {
      console.error(e);
      Swal.fire({icon: 'error', title: 'JSON読み込みエラー', text: e.message});
    }
  },

  loadSampleJson: () => {
    const sample = {
      "unitInfo": { "subject": "国語", "grade": 5, "unitName": "注文の多い料理店" },
      "tasks": [
        { "id": "t1", "category": "つかむ", "title": "導入: 扉の向こうへ", "description": "物語の入り口を読む" },
        { "id": "t2", "category": "まなぶ", "title": "色と音の表現", "description": "宮沢賢治の表現技法を探す" }
      ]
    };
    document.getElementById('jsonInput').value = JSON.stringify(sample, null, 2);
  },

  renderTaskList: () => {
    const list = document.getElementById('taskList');
    list.innerHTML = '';
    
    if (!State.unitData || !State.unitData.tasks) return;
    document.getElementById('taskCount').innerText = State.unitData.tasks.length + '件';
    
    State.unitData.tasks.forEach(task => {
      const div = document.createElement('div');
      div.className = 'list-group-item d-flex p-2 align-items-center';
      div.innerHTML = `
        <div class="me-2">
          <input class="form-check-input task-checkbox" type="checkbox" value="${task.id}" checked>
        </div>
        <button class="btn btn-link text-start text-dark p-0 w-100 text-decoration-none shadow-none" type="button">
          <div class="d-flex justify-content-between align-items-center">
            <small class="badge bg-secondary rounded-pill">${task.category || '学習'}</small>
            <small class="text-muted">${task.step || ''}</small>
          </div>
          <div class="fw-bold text-truncate small mt-1">${task.title || '無題'}</div>
        </button>`;
      
      const btn = div.querySelector('button');
      btn.onclick = () => App.selectTaskById(task.id);
      list.appendChild(div);
    });
  },

  toggleSelectAll: (cb) => {
    document.querySelectorAll('.task-checkbox').forEach(box => box.checked = cb.checked);
  },

  // --- Task Selection & Editor ---

  selectTaskById: (taskId) => {
    const task = State.unitData.tasks.find(t => t.id === taskId);
    if (task) App.selectTask(task);
  },

  selectTask: async (task) => {
    State.currentTask = task;
    
    document.getElementById('emptyState')?.classList.add('d-none');
    document.getElementById('paperArea').classList.remove('d-none');
    document.getElementById('editorToolbar').classList.remove('d-none');
    document.getElementById('currentTaskTitle').innerText = task.title || "無題";
    
    try { App.resetCanvas(); } catch(e) { console.warn(e); }
    
    // Check Mode using URL params first
    const params = new URLSearchParams(window.location.search);
    const mode = params.get('mode') || (typeof APP_CONFIG !== 'undefined' ? APP_CONFIG.mode : 'teacher');
    
    document.getElementById('worksheetContent').contentEditable = (mode === 'teacher');
    
    UI.showLoading("データを取得中...");
    try {
      const data = await Server.call('loadWorksheetFromDB', task.id);
      
      if (data) {
        document.getElementById('worksheetContent').innerHTML = data.htmlContent;
        State.currentTask.rubricHtml = data.rubricHtml;
        if (data.canvasJson) State.currentTask.canvasData = data.canvasJson;
        
        if (mode === 'student') {
          setTimeout(async () => {
            App.toggleDrawMode(true); 
            await App.loadMyResponse();
            // Compass連携: ステータス通知
            App.notifyCompass('syncStatus', { status: '途中', mode: 'normal' });
            // [New] ツールバー表示
            App.renderStudentToolbar();
          }, 500);
        }
      } else {
        const info = State.unitData?.unitInfo || {};
        document.getElementById('worksheetContent').innerHTML = `
          <div class="d-flex flex-column align-items-center justify-content-center h-100 text-muted" style="min-height: 297mm;">
            <div class="ws-header w-100">
              <div>${info.grade || ''} ${info.unitName || ''}</div>
              <div>名前: __________________</div>
            </div>
            <h1>${task.title}</h1>
            <div class="my-5 text-center">
              <p class="mb-4">この授業のワークシートはまだ作成されていません。</p>
              <button class="btn btn-primary btn-lg rounded-pill px-5 shadow-sm" onclick="App.generateSingleWorksheet()">
                <i class="bi bi-stars"></i> AIで作成する
              </button>
            </div>
          </div>`;
      }
      
      if(mode === 'teacher') Editor.enableResizing();

    } finally {
      UI.hideLoading();
    }
  },

  // --- History Management ---

  loadHistory: async () => {
    const history = await Server.call('getHistory');
    const list = document.getElementById('historyList');
    if(list) {
      list.innerHTML = '';
      history.forEach(h => {
        const btn = document.createElement('button');
        btn.className = 'list-group-item list-group-item-action small py-2';
        btn.innerHTML = `
          <div class="fw-bold text-truncate">${h.title}</div>
          <small class="text-muted" style="font-size:0.75rem">
            ${new Date(h.timestamp).toLocaleDateString()} ${new Date(h.timestamp).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}
          </small>`;
        btn.onclick = () => App.loadFromHistory(h.id);
        list.appendChild(btn);
      });
    }
  },

  loadFromHistory: async (taskId) => {
    UI.showLoading("履歴を展開中...", "データを復元しています");
    try {
      App.resetCanvas();
      const data = await Server.call('loadWorksheetFromDB', taskId);
      
      if (data) {
        document.getElementById('paperArea').classList.remove('d-none');
        document.getElementById('editorToolbar').classList.remove('d-none');
        document.getElementById('emptyState')?.classList.add('d-none');
        
        document.getElementById('worksheetContent').innerHTML = data.htmlContent;
        document.getElementById('currentTaskTitle').innerText = data.stepTitle;
        
        // Mode Check
        const params = new URLSearchParams(window.location.search);
        const mode = params.get('mode') || (typeof APP_CONFIG !== 'undefined' ? APP_CONFIG.mode : 'teacher');
        document.getElementById('worksheetContent').contentEditable = (mode === 'teacher');

        State.currentTask = {
          id: data.taskId,
          title: data.stepTitle,
          description: "",
          canvasData: data.canvasJson,
          rubricHtml: data.rubricHtml,
          ... (data.jsonSource || {})
        };
        State.currentTask.title = data.stepTitle;

        State.unitData = {
          unitInfo: { unitName: data.unitName || "復元された単元" },
          tasks: [State.currentTask]
        };

        if (mode === 'teacher') App.renderTaskList();
        
        if (mode === 'student') {
          setTimeout(async () => {
            App.toggleDrawMode(true);
            await App.loadMyResponse();
            // Compass連携 & ツールバー
            App.notifyCompass('syncStatus', { status: '途中', mode: 'normal' });
            App.renderStudentToolbar();
          }, 500);
        }
        
        if(mode === 'teacher') Editor.enableResizing();
        
      } else {
        Swal.fire('エラー', 'データが見つかりません。削除された可能性があります。', 'error');
      }
    } catch (e) {
      console.error(e);
      Swal.fire('読込エラー', '履歴の展開に失敗しました。', 'error');
    } finally {
      UI.hideLoading();
    }
  },

  // --- AI Generation (Prompt) ---

  generateSingleWorksheet: async (useOcr = false) => {
    if (!State.currentTask) return;
    UI.showLoading("AIが執筆中です", "レイアウトを構成しています...");
    try {
      let extraContext = "";
      if (useOcr && State.ocrCache) {
        extraContext = `\n【参考資料テキスト】\n${State.ocrCache.substring(0, 1500)}...\n※この資料の内容を授業に反映させてください。`;
      }

      const info = State.unitData?.unitInfo || { grade: "", unitName: "" };
      const description = State.currentTask.description || "";
      
      // Phase 4: Enhanced Prompt (called from Server Side actually in v2.2.0 proposal, 
      // but keeping local prompt logic for manual generation to maintain consistency)
      const prompt = `
        あなたは日本の小学校教師です。以下の授業情報から、児童が自立的に取り組むためのワークシートHTMLを作成してください。
        
        【授業情報】
        学年: ${info.grade}
        単元名: ${info.unitName}
        授業タイトル: ${State.currentTask.title}
        活動内容: ${description}
        ${extraContext}
        
        【出力HTMLの構成（厳守）】
        以下の構造を使用し、AIコーチング要素（ヒント、めあて）を盛り込んでください。
        Markdown記法は禁止です。

        <!-- 1. ヘッダー -->
        <div class="ws-header" style="display:flex; justify-content:space-between; align-items:end; border-bottom: 3px double #555; padding-bottom: 10px; margin-bottom: 20px; font-family: 'Zen Maru Gothic', sans-serif;">
           <div><span style="background:#333; color:#fff; padding:2px 8px; border-radius:4px; font-size:0.7em; margin-right:5px;">${info.grade}</span><span style="font-weight:bold;">${info.unitName}</span></div>
           <div style="text-align:right;">年 組 名前 __________________</div>
        </div>

        <!-- 2. タイトル & めあて -->
        <h1 style="text-align:center; font-size:1.8em; margin-bottom:20px;">${State.currentTask.title}</h1>
        <div style="background:#e3f2fd; padding:10px; border-radius:8px; margin-bottom:20px; border-left:5px solid #2196f3;">
           <strong>今日のめあて:</strong> (活動内容から子供向けのめあてを生成)
        </div>

        <!-- 3. AIヒント (Coaching) -->
        <div style="background:#fff3e0; padding:10px; border-radius:8px; margin-bottom:20px; font-size:0.9em; color:#e65100;">
           <strong><i class="bi bi-lightbulb-fill"></i> AIコーチのヒント:</strong>
           (この活動でつまずきやすい点や、考えるためのヒントを1-2行で記述)
        </div>

        <!-- 4. 本文エリア -->
        <div style="min-height: 350px;">
          (学習課題・問い・記述欄を生成。クラス名: ws-box, ws-lines, rich-editor 等を活用)
        </div>

        <!-- 5. フッター (スタンプ) -->
        <div style="margin-top: 30px; border-top: 2px dashed #ccc; padding-top: 15px; display: flex; gap: 15px;">
          <div style="flex: 6;">
            <div style="font-weight:bold; font-size:0.9em;">■ ふりかえり</div>
            <div class="ws-lines" style="height: 4.5em; background-image: linear-gradient(#ccc 1px, transparent 1px); background-size: 100% 1.5em;"></div>
          </div>
          <div style="flex: 4;">
            <div style="font-weight:bold; font-size:0.9em;">■ 自己評価</div>
            <table class="table table-bordered table-sm mb-0" style="font-size: 0.75em; text-align:center;">
              <tr><td class="bg-light">わかった</td><td><span class="eval-btn">◎</span><span class="eval-btn">◯</span><span class="eval-btn">△</span></td></tr>
              <tr><td class="bg-light">考えた</td><td><span class="eval-btn">◎</span><span class="eval-btn">◯</span><span class="eval-btn">△</span></td></tr>
              <tr><td class="bg-light">進んで</td><td><span class="eval-btn">◎</span><span class="eval-btn">◯</span><span class="eval-btn">△</span></td></tr>
            </table>
          </div>
        </div>
      `;

      let html = await Server.call('callGeminiAPI', prompt);
      html = App.cleanAIOutput(html);
      
      await Server.call('saveWorksheetToDB', {
        taskId: State.currentTask.id,
        unitName: info.unitName,
        stepTitle: State.currentTask.title,
        htmlContent: html,
        jsonSource: State.currentTask
      });
      
      App.selectTask(State.currentTask);
      
    } catch (e) {
      console.error(e);
      Swal.fire('生成エラー', 'AIによる生成に失敗しました。', 'error');
    } finally {
      UI.hideLoading();
    }
  },

  cleanAIOutput: (text) => {
    if (!text) return "";
    return text
      .replace(/```html/gi, "")
      .replace(/```/g, "")
      .replace(/^[\s\S]*?<body[^>]*>/i, "")
      .replace(/<\/body>[\s\S]*$/i, "")
      .trim();
  },

  // [Update] ターゲットIDリストを受け取るように拡張
  startBatchGeneration: async (targetTaskIds = null) => {
    let queue = [];
    
    if (targetTaskIds && Array.isArray(targetTaskIds)) {
      // IDリストが渡された場合、DBから詳細をロードしてキューに追加
      for (const tid of targetTaskIds) {
        const data = await Server.call('loadWorksheetFromDB', tid);
        if (data) {
          queue.push({
            id: data.taskId,
            title: data.stepTitle,
            description: (data.jsonSource && data.jsonSource.description) ? data.jsonSource.description : data.stepTitle,
            unitName: data.unitName,
            jsonSource: data.jsonSource
          });
        }
      }
    } else {
      // 既存ロジック（UIのチェックボックスから）
      const checkboxes = document.querySelectorAll('.task-checkbox:checked');
      if (checkboxes.length === 0) return Swal.fire('選択なし', '生成するタスクを選択してください', 'info');
      queue = Array.from(checkboxes).map(cb => State.unitData.tasks.find(t => t.id === cb.value));
    }

    if (queue.length === 0) return;
    
    if (!confirm(`${queue.length}件のワークシートを一括生成しますか？`)) return;

    UI.showLoading("一括生成を開始します", "AIが執筆中...");
    UI.toggleBatchProgress(true);
    
    try {
      for (let i = 0; i < queue.length; i++) {
        const task = queue[i];
        UI.updateBatchProgress(Math.round(((i) / queue.length) * 100), `${i + 1} / ${queue.length}: ${task.title}`);
        
        try {
          // Server-side generation function (Phase 4 Enhanced)
          const html = await Server.call('generateSingleWorksheet', {
            unitName: task.unitName || State.unitData?.unitInfo?.unitName || "単元",
            stepTitle: task.title,
            description: task.description
          });
          
          const jsonSrc = task.jsonSource || { id: task.id, title: task.title, description: task.description };

          await Server.call('saveWorksheetToDB', {
            taskId: task.id,
            unitName: task.unitName || State.unitData?.unitInfo?.unitName,
            stepTitle: task.title,
            htmlContent: html,
            jsonSource: jsonSrc
          });
        } catch (e) {
          console.error(`Task ${task.title} failed:`, e);
        }
        await new Promise(r => setTimeout(r, 1000));
      }
      
      UI.updateBatchProgress(100, '完了');
      App.loadHistory();
      UI.toast('一括生成が完了しました');
      
      // URLパラメータの掃除
      if (targetTaskIds) {
         const cleanUrl = window.location.pathname + "?mode=teacher";
         window.history.pushState({path:cleanUrl},'',cleanUrl);
      }
      
    } finally {
      setTimeout(() => {
        UI.toggleBatchProgress(false);
        UI.hideLoading();
      }, 1000);
    }
  },

  saveCurrentWorksheet: async () => {
    if (!State.currentTask) return;
    UI.showLoading("保存しています", "クラウドに同期中...");
    
    const content = document.getElementById('worksheetContent').innerHTML;
    let canvasJson = null;
    if (State.fabricCanvas) canvasJson = State.fabricCanvas.toJSON();

    const data = {
      taskId: State.currentTask.id,
      unitName: State.unitData?.unitInfo?.unitName,
      stepTitle: State.currentTask.title,
      htmlContent: content,
      jsonSource: State.currentTask,
      canvasJson: canvasJson,
      rubricHtml: State.currentTask.rubricHtml
    };

    try {
      await Server.call('saveWorksheetToDB', data);
      UI.toast("保存しました");
      
      // Mode Check
      const params = new URLSearchParams(window.location.search);
      const mode = params.get('mode') || (typeof APP_CONFIG !== 'undefined' ? APP_CONFIG.mode : 'teacher');
      if (mode === 'teacher') App.loadHistory();
      
    } finally {
      UI.hideLoading();
    }
  },

  // ★ Unified Print Methods
  printCurrentWorksheet: async () => {
    if (!State.currentTask) return;
    const html = document.getElementById('worksheetContent').innerHTML;
    let img = null;
    if (State.fabricCanvas) {
      img = State.fabricCanvas.toDataURL({ format: 'png', multiplier: 2 });
    }
    Printer.run([{ html, img }]);
  },

  startBatchPrint: async () => {
    const checkboxes = document.querySelectorAll('.task-checkbox:checked');
    if (checkboxes.length === 0) return Swal.fire('選択なし', '印刷するタスクを選択してください', 'info');
    
    const taskIds = Array.from(checkboxes).map(cb => cb.value);
    UI.showLoading("印刷データを準備中...");
    
    try {
      const sheets = await Server.call('getWorksheetsByIds', taskIds);
      const pages = sheets.map(s => ({
        html: s.htmlContent,
        img: null
      }));
      Printer.run(pages);
    } finally {
      UI.hideLoading();
    }
  },

  // --- Student & Grading Logic ---
  
  autoSaveLocal: () => {
    const params = new URLSearchParams(window.location.search);
    const mode = params.get('mode') || (typeof APP_CONFIG !== 'undefined' ? APP_CONFIG.mode : 'teacher');
    if (mode !== 'student' || !State.currentTask || !State.fabricCanvas) return;
    
    const key = `manabi_${State.currentTask.id}`;
    localStorage.setItem(key, JSON.stringify({ j: State.fabricCanvas.toJSON(), t: Date.now() }));
    const ind = document.getElementById('autoSaveIndicator');
    if(ind) ind.innerHTML = `<i class="bi bi-cloud-check"></i> ${new Date().toLocaleTimeString()}`;
  },

  loadMyResponse: async () => {
    const resp = await Server.call('getMyResponse', State.currentTask.id, State.studentId);
    if (resp) {
      if (resp.canvasJson && State.fabricCanvas) State.fabricCanvas.loadFromJSON(resp.canvasJson);
      const chk = document.getElementById('isPublicCheck');
      if(chk) chk.checked = (resp.isPublic === "" || resp.isPublic === true);
      
      if (resp.feedbackText || resp.status === 'graded') {
        const btn = document.getElementById('btnFeedback');
        if(btn) {
          btn.classList.remove('d-none');
          btn.onclick = () => Swal.fire({ title: '先生からのコメント', text: resp.feedbackText || "（コメントなし）", icon: 'info' });
          UI.toast("添削が届いています");
        }
      }
    } else {
      const local = localStorage.getItem(`manabi_${State.currentTask.id}`);
      if (local && State.fabricCanvas) {
        State.fabricCanvas.loadFromJSON(JSON.parse(local).j);
        UI.toast("下書きを復元しました");
      }
    }
  },

  submitStudentResponse: async (status) => {
    const nameInput = document.getElementById('studentNameInput');
    const name = nameInput ? nameInput.value : APP_CONFIG.studentName;
    const isPublicCheck = document.getElementById('isPublicCheck');
    const isPublic = isPublicCheck ? isPublicCheck.checked : true;
    
    if (!name && status === 'submitted') return Swal.fire('名前を入力してください', '', 'warning');
    
    UI.showLoading(status === 'draft' ? "一時保存中..." : "提出しています", "先生にデータを送信中...");
    try {
      let img = "";
      if (State.fabricCanvas) img = State.fabricCanvas.toDataURL({ format: 'png', multiplier: 0.5 });
      
      // 自己評価収集
      let evalText = "";
      const rows = document.querySelectorAll('#worksheetContent table tr');
      rows.forEach(r => {
        const label = r.querySelector('td:first-child')?.innerText;
        const activeBtn = r.querySelector('.eval-btn.active');
        if(label && activeBtn) {
           evalText += `[${label}: ${activeBtn.innerText}] `;
        }
      });

      await Server.call('saveStudentResponse', {
        taskId: State.currentTask.id,
        studentId: State.studentId,
        studentName: name || "名無し",
        canvasImage: img,
        canvasJson: JSON.stringify(State.fabricCanvas?.toJSON()),
        textContent: evalText,
        status: status,
        isPublic: isPublic
      });
      
      // Compass連携: 完了通知
      if (status === 'submitted') {
        App.notifyCompass('syncStatus', { status: 'done', mode: 'normal' });
        localStorage.removeItem(`manabi_${State.currentTask.id}`);
      }
      
      UI.toast(status === 'draft' ? "保存しました" : "提出しました！");
    } finally {
      UI.hideLoading();
    }
  },

  // --- Plaza (Gallery) Logic ---

  toggleGalleryMode: async (show) => {
    State.isGalleryMode = show;
    const workspace = document.getElementById('workspaceContainer');
    const plaza = document.getElementById('plazaPanel');
    const btnWork = document.getElementById('btnModeWork');
    const btnPlaza = document.getElementById('btnModePlaza');
    
    if (show) {
      if(btnWork) btnWork.classList.replace('btn-primary', 'btn-light');
      if(btnPlaza) btnPlaza.classList.replace('btn-light', 'btn-primary');
      if(workspace) workspace.classList.add('scale-down-mode');
      if(plaza) plaza.classList.remove('d-none');
      await App.loadPlazaItems();
    } else {
      if(btnWork) btnWork.classList.replace('btn-light', 'btn-primary');
      if(btnPlaza) btnPlaza.classList.replace('btn-primary', 'btn-light');
      if(workspace) workspace.classList.remove('scale-down-mode');
      if(plaza) plaza.classList.add('d-none');
    }
  },

  loadPlazaItems: async () => {
    const grid = document.getElementById('plazaGrid');
    if(!grid) return;
    grid.innerHTML = '<div class="text-center w-100 py-5"><div class="spinner-border text-primary"></div></div>';
    try {
      const items = await Server.call('getSharedResponses', State.currentTask.id);
      grid.innerHTML = '';
      if (!items || items.length === 0) {
        grid.innerHTML = '<div class="col-12 text-center py-5 text-muted">まだ誰も提出していません</div>';
      } else {
        items.forEach(i => {
          if(i.studentId === State.studentId) return;
          const col = document.createElement('div');
          col.className = 'col-6';
          col.innerHTML = `
            <div class="card h-100 shadow-sm border-0" style="cursor:pointer; transition:transform 0.2s;" onmouseover="this.style.transform='scale(1.02)'" onmouseout="this.style.transform='scale(1)'">
              <div class="bg-light d-flex align-items-center justify-content-center overflow-hidden position-relative" style="aspect-ratio: 210/297;">
                <img src="${i.canvasImage}" class="img-fluid" style="object-fit:contain;">
              </div>
              <div class="card-footer bg-white border-top-0 py-1 px-2 text-center">
                <small class="fw-bold text-truncate d-block">${i.studentName}</small>
              </div>
            </div>`;
          col.onclick = () => App.openPlazaDetail(i);
          grid.appendChild(col);
        });
      }
    } catch(e) { grid.innerHTML = 'Error'; }
  },

  openPlazaDetail: (item) => {
    State.currentPeerResponse = item;
    if(!Array.isArray(item.reactions)) item.reactions = [];
    document.getElementById('plazaGrid').classList.add('d-none');
    document.getElementById('plazaDetail').classList.remove('d-none');
    document.getElementById('plazaDetail').classList.add('d-flex');
    document.getElementById('plazaDetailName').innerText = `${item.studentName} さんの作品`;
    const myContent = document.getElementById('worksheetContent').innerHTML;
    document.getElementById('plazaPeerContent').innerHTML = myContent;
    const cvEl = document.getElementById('plazaPeerCanvas');
    cvEl.width = 794; cvEl.height = 1123; 
    if(State.peerCanvas) State.peerCanvas.dispose();
    State.peerCanvas = new fabric.Canvas('plazaPeerCanvas', { selection: false });
    if(item.canvasJson) {
      State.peerCanvas.loadFromJSON(item.canvasJson, () => {
          State.peerCanvas.forEachObject(o => o.selectable = false);
          State.peerCanvas.renderAll();
      });
    }
    App.renderPeerReactions(item.reactions);
  },

  closePlazaDetail: () => {
    document.getElementById('plazaDetail').classList.add('d-none');
    document.getElementById('plazaDetail').classList.remove('d-flex');
    document.getElementById('plazaGrid').classList.remove('d-none');
    State.currentPeerResponse = null;
  },

  sendReaction: async (type, value) => {
    if(!State.currentPeerResponse) return;
    if(!Array.isArray(State.currentPeerResponse.reactions)) State.currentPeerResponse.reactions = [];
    const commentInput = document.getElementById('reactionComment');
    const val = type === 'comment' ? commentInput.value : value;
    if(!val) return;
    
    const myName = document.getElementById('studentNameInput') ? document.getElementById('studentNameInput').value : '自分';
    const tempReaction = { type, value: val, fromName: myName };
    State.currentPeerResponse.reactions.push(tempReaction);
    App.renderPeerReactions(State.currentPeerResponse.reactions);
    if(type === 'comment') commentInput.value = '';
    await Server.call('savePeerReaction', {
      taskId: State.currentTask.id,
      targetResponseId: State.currentPeerResponse.responseId,
      reaction: tempReaction
    });
    UI.toast('送りました！');
  },

  renderPeerReactions: (list) => {
    const div = document.getElementById('peerReactionsList');
    div.innerHTML = '';
    if(!Array.isArray(list) || list.length === 0) return;
    list.slice(-5).forEach(r => {
      const d = document.createElement('div');
      d.className = 'border-bottom py-1';
      d.innerHTML = `<span class="fw-bold me-2">${r.fromName}</span> ${r.value}`;
      div.appendChild(d);
    });
  },

  // --- Teacher Grading ---
  openGrading: (index) => {
    const s = State.dashboardData[index];
    State.gradingRow = s.rowIndex;
    bootstrap.Modal.getInstance(document.getElementById('dashboardModal')).hide();
    const container = document.getElementById('gradingContainer');
    container.innerHTML = `<div id="gradingPaper" class="sheet shadow-sm"><div class="p-5">${document.getElementById('worksheetContent').innerHTML}</div></div><canvas id="gradingCanvas"></canvas>`;
    new bootstrap.Modal(document.getElementById('gradingModal')).show();
    setTimeout(() => {
      const paper = document.getElementById('gradingPaper');
      const cv = document.getElementById('gradingCanvas');
      cv.width = paper.offsetWidth;
      cv.height = paper.offsetHeight;
      cv.style.position = 'absolute';
      cv.style.top = paper.offsetTop + 'px';
      cv.style.left = paper.offsetLeft + 'px';
      cv.style.zIndex = 99;
      const gCanvas = new fabric.Canvas('gradingCanvas', { isDrawingMode: true });
      gCanvas.freeDrawingBrush.width = 3;
      gCanvas.freeDrawingBrush.color = "red";
      if (s.canvasJson) gCanvas.loadFromJSON(s.canvasJson);
      State.gradingCanvas = gCanvas;
      document.getElementById('gradingTitle').innerText = `${s.studentName} さんの回答`;
      document.getElementById('feedbackTextInput').value = s.feedbackText || "";
    }, 500);
  },

  saveGrading: async () => {
    if (!State.gradingRow) return;
    UI.showLoading("返却しています", "コメントと添削内容を保存中...");
    try {
      await Server.call('saveFeedback', {
        rowIndex: State.gradingRow,
        feedbackText: document.getElementById('feedbackTextInput').value,
        canvasJson: JSON.stringify(State.gradingCanvas.toJSON())
      });
      bootstrap.Modal.getInstance(document.getElementById('gradingModal')).hide();
      UI.toast("返却しました");
    } finally {
      UI.hideLoading();
    }
  },

  // --- Other Utils ---
  generateRubric: async () => {
    UI.showLoading("ルーブリック作成中...");
    try {
      let h = await Server.call('generateRubricAI', {
        unitName: "",
        stepTitle: State.currentTask.title,
        description: State.currentTask.description
      });
      h = App.cleanAIOutput(h);
      document.getElementById('rubricContainer').innerHTML = h;
    } finally {
      UI.hideLoading();
    }
  },

  saveRubric: () => {
    State.currentTask.rubricHtml = document.getElementById('rubricContainer').innerHTML;
    App.saveCurrentWorksheet();
    bootstrap.Modal.getInstance(document.getElementById('rubricModal')).hide();
  },

  showShareUrl: async () => {
    if (!State.currentTask) return;
    const url = await Server.call('getWebAppUrl');
    const shareUrl = `${url}?mode=student&taskId=${State.currentTask.id}`;
    document.getElementById('shareUrlInput').value = shareUrl;
    new bootstrap.Modal(document.getElementById('shareModal')).show();
  },

  processOcrImport: async () => { /* OCR placeholder */ },

  initFabric: () => {
    if (!State.fabricCanvas) {
      const c = document.getElementById('drawCanvas');
      if (c) State.fabricCanvas = new fabric.Canvas('drawCanvas', { isDrawingMode: false });
    }
  },

  resetCanvas: () => {
    if (State.fabricCanvas) {
      try { State.fabricCanvas.clear(); State.fabricCanvas.dispose(); } catch(e){}
      State.fabricCanvas = null;
    }
    const cv = document.getElementById('drawCanvas');
    if (cv) cv.classList.add('d-none');
    App.toggleDrawMode(false);
  },

  toggleDrawMode: (forceState) => {
    const newState = (forceState !== undefined) ? forceState : !State.isDrawMode;
    State.isDrawMode = newState;
    const btn = document.getElementById('btnDrawMode');
    const tools = document.getElementById('drawTools');
    const cv = document.getElementById('drawCanvas');
    const pp = document.getElementById('paperArea');
    if(btn) btn.classList.replace(newState ? 'btn-outline-dark' : 'btn-dark', newState ? 'btn-dark' : 'btn-outline-dark');
    if(tools) newState ? tools.classList.remove('d-none') : tools.classList.add('d-none');
    if (newState) {
      if(cv) {
        cv.classList.remove('d-none');
        cv.style.position = 'absolute'; cv.style.left = '0'; cv.style.top = '0';
        if(pp) { cv.width = pp.offsetWidth; cv.height = pp.offsetHeight; }
      }
      if (!State.fabricCanvas && cv) {
        try { State.fabricCanvas = new fabric.Canvas('drawCanvas', { isDrawingMode: true, freeDrawingBrush: { width: 3, color: '#ff0000' } }); } catch(e){}
      } else if (State.fabricCanvas) {
        State.fabricCanvas.isDrawingMode = true;
      }
      if (State.currentTask?.canvasData && State.fabricCanvas) {
        try { State.fabricCanvas.loadFromJSON(State.currentTask.canvasData); } catch(e){}
      }
      document.getElementById('worksheetContent').contentEditable = false;
    } else {
      if (State.fabricCanvas) State.fabricCanvas.isDrawingMode = false;
      const cnt = document.querySelector('.canvas-container');
      if(cnt) cnt.style.pointerEvents = 'none';
      
      const params = new URLSearchParams(window.location.search);
      const mode = params.get('mode') || (typeof APP_CONFIG !== 'undefined' ? APP_CONFIG.mode : 'teacher');
      document.getElementById('worksheetContent').contentEditable = (mode === 'teacher');
    }
  },

  updateBrush: () => { if (State.fabricCanvas) State.fabricCanvas.freeDrawingBrush.color = document.getElementById('penColor').value; },
  clearCanvas: () => { if (State.fabricCanvas) State.fabricCanvas.clear(); },
  insertImage: (input) => {
    if(input.files && input.files[0]){
      const r = new FileReader();
      r.onload = e => {
        const i = new Image();
        i.onload = () => {
          const c = document.createElement('canvas'), x = c.getContext('2d'), M = 800;
          let w=i.width, h=i.height;
          if(w>h){if(w>M){h*=M/w;w=M}}else{if(h>M){w*=M/h;h=M}}
          c.width=w; c.height=h; x.drawImage(i,0,0,w,h);
          const u = c.toDataURL('image/jpeg', 0.7);
          
          if(State.isDrawMode && State.fabricCanvas) {
            fabric.Image.fromURL(u, o => {
              o.scaleToWidth(300);
              State.fabricCanvas.add(o);
              State.fabricCanvas.centerObject(o);
            });
          } else {
            App.insertAtCursor(`<img src="${u}" style="max-width:100%; border:1px solid #ccc; display:block; margin:10px auto;">`);
          }
        };
        i.src = e.target.result;
      };
      r.readAsDataURL(input.files[0]);
    }
    input.value = '';
  },
  insertAtCursor: (html) => {
    const e = document.getElementById('worksheetContent');
    e.focus();
    const s = window.getSelection();
    if(s.getRangeAt && s.rangeCount) {
      const r = s.getRangeAt(0);
      if(e.contains(r.commonAncestorContainer)) {
        r.deleteContents();
        const d = document.createElement("div");
        d.innerHTML = html;
        const f = document.createDocumentFragment();
        let n;
        while((n=d.firstChild)) f.appendChild(n);
        r.insertNode(f);
        return;
      }
    }
    e.insertAdjacentHTML('beforeend', html);
  }
};

// ==============================================
// Rich Editor Module
// ==============================================
const Editor = {
  currentTarget: null,

  init: () => {
    const menu = document.createElement('div');
    menu.id = 'ctxMenu';
    menu.className = 'dropdown-menu shadow';
    menu.style.position = 'fixed';
    menu.style.display = 'none';
    menu.style.zIndex = '9999';
    document.body.appendChild(menu);

    document.addEventListener('contextmenu', (e) => {
      const ws = document.getElementById('worksheetContent');
      if (!ws || !ws.contains(e.target)) return;
      if(document.getElementById('worksheetContent').contentEditable !== "true") return;

      e.preventDefault();
      Editor.showContextMenu(e, menu);
    });

    document.addEventListener('click', () => menu.style.display = 'none');
    Editor.enableResizing();
  },

  enableResizing: () => {
    const oldStyle = document.getElementById('editor-style');
    if(oldStyle) oldStyle.remove();

    const style = document.createElement('style');
    style.id = 'editor-style';
    style.innerHTML = `
      .ws-box, .ws-lines { 
        resize: vertical; 
        overflow: hidden; 
        position: relative; 
        min-height: 50px;
      }
      @media print { .ws-box, .ws-lines { resize: none; overflow: visible; } }
      
      #worksheetContent[contenteditable="true"] .ws-box:hover,
      #worksheetContent[contenteditable="true"] .ws-lines:hover,
      #worksheetContent[contenteditable="true"] table:hover {
        outline: 2px dashed #a2d2ff;
        cursor: text;
      }
    `;
    document.head.appendChild(style);
  },

  showContextMenu: (e, menu) => {
    const t = e.target;
    let items = [];
    Editor.currentTarget = t;

    const td = t.closest('td, th');
    if (td) {
      items = [
        { label: '<i class="bi bi-arrow-bar-up"></i> 行を上に追加', action: () => Editor.tableAction('addRowUp', td) },
        { label: '<i class="bi bi-arrow-bar-down"></i> 行を下に追加', action: () => Editor.tableAction('addRowDown', td) },
        { divider: true },
        { label: '<i class="bi bi-arrow-bar-left"></i> 列を左に追加', action: () => Editor.tableAction('addColLeft', td) },
        { label: '<i class="bi bi-arrow-bar-right"></i> 列を右に追加', action: () => Editor.tableAction('addColRight', td) },
        { divider: true },
        { label: '<i class="bi bi-trash"></i> 行を削除', action: () => Editor.tableAction('delRow', td) },
        { label: '<i class="bi bi-trash"></i> 列を削除', action: () => Editor.tableAction('delCol', td) }
      ];
    } else if (t.classList.contains('ws-box') || t.classList.contains('ws-lines')) {
      items = [
        { label: '<i class="bi bi-files"></i> ボックスを複製', action: () => Editor.cloneElement(t) },
        { label: '<i class="bi bi-trash"></i> 削除', action: () => t.remove() }
      ];
    } else {
      items = [
        { label: '<i class="bi bi-type-bold"></i> 太字', action: () => document.execCommand('bold') },
        { label: '<i class="bi bi-trash"></i> 削除', action: () => t.remove() }
      ];
    }

    if (items.length === 0) return;

    menu.innerHTML = '';
    items.forEach(i => {
      if (i.divider) {
        menu.innerHTML += '<div class="dropdown-divider"></div>';
      } else {
        const a = document.createElement('a');
        a.className = 'dropdown-item';
        a.href = '#';
        a.innerHTML = i.label;
        a.onclick = (ev) => { ev.preventDefault(); i.action(); };
        menu.appendChild(a);
      }
    });

    menu.style.left = `${e.pageX}px`;
    menu.style.top = `${e.pageY}px`;
    menu.style.display = 'block';
  },

  tableAction: (type, cell) => {
    const row = cell.parentElement;
    const table = row.parentElement.parentElement;
    const rowIndex = row.rowIndex;
    const colIndex = cell.cellIndex;

    switch(type) {
      case 'addRowUp': table.insertRow(rowIndex); break;
      case 'addRowDown': table.insertRow(rowIndex + 1); break;
      case 'delRow': table.deleteRow(rowIndex); break;
      case 'addColLeft': for (let r of table.rows) r.insertCell(colIndex); break;
      case 'addColRight': for (let r of table.rows) r.insertCell(colIndex + 1); break;
      case 'delCol': for (let r of table.rows) r.deleteCell(colIndex); break;
    }
  },

  cloneElement: (el) => {
    const clone = el.cloneNode(true);
    el.after(clone);
  }
};

document.addEventListener('DOMContentLoaded', App.init);
</script>
