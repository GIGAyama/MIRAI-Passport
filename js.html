<script>
/**
 * みらいパスポート v1.0
 * Robust Logic & Readable Code Refactoring
 */

// ==============================================
// Server Communication Wrapper
// ==============================================
const Server = {
  call: (funcName, ...args) => {
    return new Promise((resolve, reject) => {
      google.script.run
        .withSuccessHandler(resolve)
        .withFailureHandler((error) => {
          UI.hideLoading();
          console.error(`Server Error [${funcName}]:`, error);
          Swal.fire('通信エラー', error.message || '予期せぬエラーが発生しました', 'error');
          reject(error);
        })
        [funcName](...args);
    });
  }
};

// ==============================================
// UI Utilities
// ==============================================
const UI = {
  showLoading: (mainText, subText = "しばらくお待ちください") => {
    const txt = document.getElementById('loadingText');
    const sub = document.getElementById('loadingSubText');
    if (txt) txt.innerText = mainText;
    if (sub) sub.innerText = subText;
    document.getElementById('loadingOverlay').classList.remove('d-none');
  },

  hideLoading: () => {
    document.getElementById('loadingOverlay').classList.add('d-none');
  },

  toast: (title, icon = 'success') => {
    Swal.mixin({
      toast: true,
      position: 'top-end',
      showConfirmButton: false,
      timer: 2000
    }).fire({ icon, title });
  },

  updateBatchProgress: (percent, text) => {
    const bar = document.getElementById('batchProgressBar');
    const txt = document.getElementById('batchProgressText');
    if (bar) bar.style.width = `${percent}%`;
    if (txt) txt.innerText = text;
  },

  toggleBatchProgress: (show) => {
    const el = document.getElementById('batchProgressContainer');
    if (el) show ? el.classList.remove('d-none') : el.classList.add('d-none');
  }
};

// ==============================================
// Modal Controllers
// ==============================================
const Modals = {
  openSettings: () => new bootstrap.Modal(document.getElementById('settingsModal')).show(),
  openImport: () => new bootstrap.Modal(document.getElementById('importModal')).show(),
  openPdfImport: () => new bootstrap.Modal(document.getElementById('pdfImportModal')).show(),

  openRubric: () => {
    if (!State.currentTask) return Swal.fire('エラー', '授業を選択してください', 'warning');
    const container = document.getElementById('rubricContainer');
    container.innerHTML = State.currentTask.rubricHtml || 
      `<div class="text-center py-5 text-muted">
         <p class="mb-0">「AI作成」ボタンを押して評価基準を作成してください。</p>
       </div>`;
    new bootstrap.Modal(document.getElementById('rubricModal')).show();
  },

  openDashboard: async () => {
    if (!State.currentTask) return Swal.fire('エラー', '授業を選択してください', 'warning');
    
    UI.showLoading("提出状況を取得中...");
    try {
      let subs = await Server.call('getTaskSubmissions', State.currentTask.id);
      if (!subs) subs = [];
      
      State.dashboardData = subs; // メモリに保存
      const grid = document.getElementById('dashboardGrid');
      grid.innerHTML = '';

      if (subs.length === 0) {
        grid.innerHTML = '<div class="col-12 text-center py-5 text-muted">提出された回答はありません</div>';
      } else {
        subs.forEach((s, index) => {
          const col = document.createElement('div');
          col.className = 'col-md-3 col-sm-6';
          
          const statusBadge = s.status === 'graded' 
            ? '<span class="badge bg-primary">添削済</span>' 
            : '<span class="badge bg-success">提出済</span>';
            
          const imgHtml = s.canvasImage 
            ? `<img src="${s.canvasImage}" style="max-height:100%; max-width:100%; object-fit:contain;">`
            : '<span class="text-muted small">No Image</span>';

          col.innerHTML = `
            <div class="card h-100 shadow-sm" style="cursor:pointer;" onclick="App.openGrading(${index})">
              <div class="card-img-top bg-light d-flex align-items-center justify-content-center" style="height:150px; overflow:hidden;">
                ${imgHtml}
              </div>
              <div class="card-body p-2">
                <h6 class="card-title fw-bold mb-1 text-truncate">${s.studentName}</h6>
                <div class="d-flex justify-content-between align-items-center">
                  ${statusBadge}
                  <small class="text-muted" style="font-size:0.7em">${new Date(s.submittedAt).toLocaleTimeString()}</small>
                </div>
              </div>
            </div>`;
          grid.appendChild(col);
        });
      }
      new bootstrap.Modal(document.getElementById('dashboardModal')).show();
    } finally {
      UI.hideLoading();
    }
  },

  openGallery: async () => {
    UI.showLoading("広場へ移動中...");
    try {
      const items = await Server.call('getSharedResponses', State.currentTask.id);
      const grid = document.getElementById('galleryGrid');
      grid.innerHTML = '';
      
      if (!items || items.length === 0) {
        grid.innerHTML = '<div class="col-12 text-center py-5 text-muted">共有されている作品はありません</div>';
      } else {
        items.forEach(i => {
          const col = document.createElement('div');
          col.className = 'col-md-4 mb-3';
          col.innerHTML = `
            <div class="card h-100 shadow-sm">
              <div class="bg-light d-flex align-items-center justify-content-center" style="height:200px; overflow:hidden;">
                <img src="${i.canvasImage}" class="img-fluid" style="max-height:100%;">
              </div>
              <div class="card-body text-center p-2">
                <small class="fw-bold">${i.studentName}</small>
              </div>
            </div>`;
          grid.appendChild(col);
        });
      }
      new bootstrap.Modal(document.getElementById('galleryModal')).show();
    } finally {
      UI.hideLoading();
    }
  }
};

// ==============================================
// Global State Management
// ==============================================
const State = {
  unitData: null,      // 単元計画データ (JSON)
  currentTask: null,   // 現在選択中の授業タスク
  fabricCanvas: null,  // 手書きキャンバスインスタンス
  isDrawMode: false,   // 手書きモードフラグ
  ocrCache: "",        // OCR解析結果テキスト
  studentId: null,     // 児童ID (LocalStorage)
  gradingRow: null,    // 添削中の行番号
  dashboardData: []    // ダッシュボード用データキャッシュ
};

// ==============================================
// Main Application Logic
// ==============================================
const App = {
  
  // --- Initialization ---
  init: async () => {
    // Student Setup
    if (APP_CONFIG.mode === 'student') {
      State.studentId = localStorage.getItem('manabi_sid');
      if (!State.studentId) {
        State.studentId = 'S_' + Date.now() + Math.random().toString(36).substr(2, 5);
        localStorage.setItem('manabi_sid', State.studentId);
      }
      // Auto-save loop
      setInterval(App.autoSaveLocal, 10000);
    }

    // View Setup
    if (APP_CONFIG.mode === 'teacher') {
      UI.showLoading("システムを起動しています", "ユーザー設定を確認中...");
      const status = await Server.call('checkSetupStatus');
      if (status.isSetup) {
        document.getElementById('setupWizard').classList.add('d-none');
        document.getElementById('appContainer').classList.remove('d-none');
        App.loadConfig();
      } else {
        UI.hideLoading();
        document.getElementById('setupWizard').classList.remove('d-none');
      }
    } else {
      // Student View
      UI.showLoading("ワークシートを準備しています", "課題データをダウンロード中...");
      document.getElementById('appContainer').classList.remove('d-none');
      if (APP_CONFIG.taskId) {
        App.loadFromHistory(APP_CONFIG.taskId);
      } else {
        UI.hideLoading();
        Swal.fire('エラー', '課題IDが無効です。URLを確認してください。', 'error');
      }
    }
  },

  performSetup: async () => {
    UI.showLoading("データベースを構築しています", "初期化処理を実行中...");
    try {
      await Server.call('performInitialSetup');
      location.reload(); // リロードして設定を反映
    } catch (e) {
      console.error(e);
    }
  },

  loadConfig: async () => {
    const config = await Server.call('getUserConfig');
    document.getElementById('apiKeyInput').value = config.apiKey;
    document.getElementById('teacherNameInput').value = config.teacherName;
    UI.hideLoading();
    App.loadHistory();
  },

  saveSettings: async () => {
    await Server.call('saveUserConfig',
      document.getElementById('apiKeyInput').value,
      document.getElementById('teacherNameInput').value
    );
    UI.toast('設定を保存しました');
    bootstrap.Modal.getInstance(document.getElementById('settingsModal')).hide();
  },

  // --- Data Management (JSON Import) ---

  processImport: () => {
    try {
      const inputVal = document.getElementById('jsonInput').value;
      
      // クリーニング: Markdown記法や余計な文字を削除してJSON部分を抽出
      const firstBrace = inputVal.indexOf('{');
      const lastBrace = inputVal.lastIndexOf('}');
      
      if (firstBrace === -1 || lastBrace === -1) {
        throw new Error("有効なJSONデータが見つかりません。");
      }
      
      const jsonString = inputVal.substring(firstBrace, lastBrace + 1);
      const json = JSON.parse(jsonString);

      // 簡易バリデーション
      if (!json.tasks || !Array.isArray(json.tasks)) {
        throw new Error("JSONデータに 'tasks' 配列が含まれていません。");
      }

      State.unitData = json;
      App.renderTaskList();
      
      bootstrap.Modal.getInstance(document.getElementById('importModal')).hide();
      UI.toast('計画を読み込みました');
      
    } catch (e) {
      console.error(e);
      Swal.fire({
        icon: 'error',
        title: 'JSON読み込みエラー',
        text: '形式が正しくありません。エラー詳細: ' + e.message,
        footer: 'AIが生成したコードブロック(```json)が含まれていても自動除去しますが、構文自体が壊れている可能性があります。'
      });
    }
  },

  loadSampleJson: () => {
    const sample = {
      "unitInfo": { "subject": "国語", "grade": 5, "unitName": "注文の多い料理店" },
      "tasks": [
        { "id": "t1", "category": "つかむ", "title": "導入: 扉の向こうへ", "description": "物語の入り口を読む" },
        { "id": "t2", "category": "まなぶ", "title": "色と音の表現", "description": "宮沢賢治の表現技法を探す" }
      ]
    };
    document.getElementById('jsonInput').value = JSON.stringify(sample, null, 2);
  },

  renderTaskList: () => {
    const list = document.getElementById('taskList');
    list.innerHTML = '';
    
    if (!State.unitData || !State.unitData.tasks) return;
    document.getElementById('taskCount').innerText = State.unitData.tasks.length + '件';
    
    State.unitData.tasks.forEach(task => {
      const div = document.createElement('div');
      div.className = 'list-group-item d-flex p-2 align-items-center';
      div.innerHTML = `
        <div class="me-2">
          <input class="form-check-input task-checkbox" type="checkbox" value="${task.id}" checked>
        </div>
        <button class="btn btn-link text-start text-dark p-0 w-100 text-decoration-none shadow-none" type="button">
          <div class="d-flex justify-content-between align-items-center">
            <small class="badge bg-secondary rounded-pill">${task.category || '学習'}</small>
            <small class="text-muted">${task.step || ''}</small>
          </div>
          <div class="fw-bold text-truncate small mt-1">${task.title || '無題'}</div>
        </button>`;
      
      // 安全なイベントリスナー設定 (IDで紐付け)
      const btn = div.querySelector('button');
      btn.onclick = () => App.selectTaskById(task.id);
      
      list.appendChild(div);
    });
  },

  toggleSelectAll: (cb) => {
    document.querySelectorAll('.task-checkbox').forEach(box => box.checked = cb.checked);
  },

  // --- Task Selection & Editor ---

  selectTaskById: (taskId) => {
    const task = State.unitData.tasks.find(t => t.id === taskId);
    if (task) App.selectTask(task);
  },

  selectTask: async (task) => {
    State.currentTask = task;
    
    // UI表示切替
    document.getElementById('emptyState')?.classList.add('d-none');
    document.getElementById('paperArea').classList.remove('d-none');
    document.getElementById('editorToolbar').classList.remove('d-none');
    document.getElementById('currentTaskTitle').innerText = task.title || "無題";
    
    // キャンバスリセット
    try { App.resetCanvas(); } catch(e) { console.warn(e); }
    
    document.getElementById('worksheetContent').contentEditable = (APP_CONFIG.mode === 'teacher');
    
    UI.showLoading("データを取得中...");
    
    try {
      const data = await Server.call('loadWorksheetFromDB', task.id);
      
      if (data) {
        document.getElementById('worksheetContent').innerHTML = data.htmlContent;
        State.currentTask.rubricHtml = data.rubricHtml;
        if (data.canvasJson) State.currentTask.canvasData = data.canvasJson;
        
        if (APP_CONFIG.mode === 'student') {
          setTimeout(async () => {
            App.toggleDrawMode(true);
            await App.loadMyResponse();
          }, 500);
        }
      } else {
        // データなし（未作成）の場合
        const info = State.unitData?.unitInfo || {};
        document.getElementById('worksheetContent').innerHTML = `
          <div class="d-flex flex-column align-items-center justify-content-center h-100 text-muted">
            <div class="ws-header w-100">
              <div>${info.grade || ''} ${info.unitName || ''}</div>
              <div>名前: __________________</div>
            </div>
            <h1>${task.title}</h1>
            <div class="my-5 text-center">
              <p class="mb-4">この授業のワークシートはまだ作成されていません。</p>
              <button class="btn btn-primary btn-lg rounded-pill px-5 shadow-sm" onclick="App.generateSingleWorksheet()">
                <i class="bi bi-stars"></i> AIで作成する
              </button>
            </div>
          </div>`;
      }
    } finally {
      UI.hideLoading();
    }
  },

  // --- History Management ---

  loadHistory: async () => {
    const history = await Server.call('getHistory');
    const list = document.getElementById('historyList');
    list.innerHTML = '';
    
    history.forEach(h => {
      const btn = document.createElement('button');
      btn.className = 'list-group-item list-group-item-action small py-2';
      btn.innerHTML = `
        <div class="fw-bold text-truncate">${h.title}</div>
        <small class="text-muted" style="font-size:0.75rem">
          ${new Date(h.timestamp).toLocaleDateString()} ${new Date(h.timestamp).toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}
        </small>`;
      btn.onclick = () => App.loadFromHistory(h.id);
      list.appendChild(btn);
    });
  },

  loadFromHistory: async (taskId) => {
    UI.showLoading("履歴を展開中...", "データを復元しています");
    try {
      App.resetCanvas();
      const data = await Server.call('loadWorksheetFromDB', taskId);
      
      if (data) {
        // 画面表示
        document.getElementById('paperArea').classList.remove('d-none');
        document.getElementById('editorToolbar').classList.remove('d-none');
        document.getElementById('emptyState')?.classList.add('d-none');
        
        document.getElementById('worksheetContent').innerHTML = data.htmlContent;
        document.getElementById('currentTaskTitle').innerText = data.stepTitle;
        document.getElementById('worksheetContent').contentEditable = (APP_CONFIG.mode === 'teacher');

        // データ構造の復元（レガシー互換性確保）
        State.currentTask = {
          id: data.taskId,
          title: data.stepTitle,
          description: "", // 履歴からは説明文が取れない場合がある
          canvasData: data.canvasJson,
          rubricHtml: data.rubricHtml,
          ... (data.jsonSource || {})
        };
        State.currentTask.title = data.stepTitle; // 確実なタイトル

        State.unitData = {
          unitInfo: { unitName: data.unitName || "復元された単元" },
          tasks: [State.currentTask]
        };

        if (APP_CONFIG.mode === 'teacher') App.renderTaskList();
        
        if (APP_CONFIG.mode === 'student') {
          setTimeout(async () => {
            App.toggleDrawMode(true);
            await App.loadMyResponse();
          }, 500);
        }
      } else {
        Swal.fire('エラー', 'データが見つかりません。削除された可能性があります。', 'error');
      }
    } catch (e) {
      console.error(e);
      Swal.fire('読込エラー', '履歴の展開に失敗しました。', 'error');
    } finally {
      UI.hideLoading();
    }
  },

  // --- AI Generation ---

  generateSingleWorksheet: async (useOcr = false) => {
    if (!State.currentTask) return;
    UI.showLoading("AIが執筆中です", "レイアウトを構成しています...");
    try {
      let extraContext = "";
      if (useOcr && State.ocrCache) {
        extraContext = `\n【参考資料テキスト】\n${State.ocrCache.substring(0, 1500)}...\n※この資料の内容を授業に反映させてください。`;
      }

      const info = State.unitData?.unitInfo || { grade: "", unitName: "" };
      const prompt = `
        あなたは日本の小学校教師です。以下の授業情報からワークシートのHTML(body内部のみ)を作成してください。
        
        【授業情報】
        学年: ${info.grade}
        単元名: ${info.unitName}
        授業タイトル: ${State.currentTask.title}
        活動内容: ${State.currentTask.description}
        ${extraContext}
        
        【出力要件】
        1. 出力は純粋なHTMLコードのみとしてください。Markdown記法（\`\`\`html）や挨拶文は一切不要です。
        2. 以下のCSSクラスを使ってデザインしてください：
           - <div class="ws-header">...</div> (名前欄など)
           - <h1>タイトル</h1>
           - <div class="ws-box">...</div> (囲み枠・記述欄)
           - <div class="ws-lines">...</div> (罫線のみの記述欄)
           - <table class="table table-bordered">...</table> (表)
        3. 低学年の場合は漢字を減らし、平易な表現にしてください。
      `;

      let html = await Server.call('callGeminiAPI', prompt);
      
      // クリーニング
      html = App.cleanAIOutput(html);
      
      // 自動保存
      await Server.call('saveWorksheetToDB', {
        taskId: State.currentTask.id,
        unitName: info.unitName,
        stepTitle: State.currentTask.title,
        htmlContent: html,
        jsonSource: State.currentTask
      });
      
      App.selectTask(State.currentTask); // 再読み込みして表示
      
    } catch (e) {
      console.error(e);
      Swal.fire('生成エラー', 'AIによる生成に失敗しました。時間をおいて試してください。', 'error');
    } finally {
      UI.hideLoading();
    }
  },

  cleanAIOutput: (text) => {
    if (!text) return "";
    return text
      .replace(/```html/gi, "")
      .replace(/```/g, "")
      .replace(/^[\s\S]*?<body[^>]*>/i, "") // bodyタグ以前削除
      .replace(/<\/body>[\s\S]*$/i, "")     // bodyタグ以降削除
      .trim();
  },

  startBatchGeneration: async () => {
    const checkboxes = document.querySelectorAll('.task-checkbox:checked');
    if (checkboxes.length === 0) return Swal.fire('選択なし', '生成するタスクを選択してください', 'info');

    const queue = Array.from(checkboxes).map(cb => State.unitData.tasks.find(t => t.id === cb.value));
    if (!confirm(`${queue.length}件のワークシートを一括生成しますか？`)) return;

    UI.showLoading("一括生成を開始します", "しばらくそのままお待ちください...");
    UI.toggleBatchProgress(true);
    
    const info = State.unitData.unitInfo;

    try {
      for (let i = 0; i < queue.length; i++) {
        const task = queue[i];
        UI.updateBatchProgress(Math.round(((i) / queue.length) * 100), `${i + 1} / ${queue.length}: ${task.title}`);
        
        try {
          const prompt = `小学校ワークシートHTML作成: 学年${info.grade}, 単元${info.unitName}, タイトル:${task.title}, 活動:${task.description}。Markdown禁止。HTMLのみ。`;
          let html = await Server.call('callGeminiAPI', prompt);
          html = App.cleanAIOutput(html);
          
          await Server.call('saveWorksheetToDB', {
            taskId: task.id,
            unitName: info.unitName,
            stepTitle: task.title,
            htmlContent: html,
            jsonSource: task
          });
        } catch (e) {
          console.error(`Task ${task.title} failed:`, e);
        }
        
        // Rate Limit回避のための待機
        await new Promise(r => setTimeout(r, 1500));
      }
      
      UI.updateBatchProgress(100, '完了');
      App.loadHistory();
      UI.toast('一括生成が完了しました');
      
    } finally {
      setTimeout(() => {
        UI.toggleBatchProgress(false);
        UI.hideLoading();
      }, 1000);
    }
  },

  saveCurrentWorksheet: async () => {
    if (!State.currentTask) return;
    UI.showLoading("保存しています", "クラウドに同期中...");
    
    const content = document.getElementById('worksheetContent').innerHTML;
    let canvasJson = null;
    if (State.fabricCanvas) canvasJson = State.fabricCanvas.toJSON();

    const data = {
      taskId: State.currentTask.id,
      unitName: State.unitData?.unitInfo?.unitName,
      stepTitle: State.currentTask.title,
      htmlContent: content,
      jsonSource: State.currentTask,
      canvasJson: canvasJson,
      rubricHtml: State.currentTask.rubricHtml
    };

    try {
      await Server.call('saveWorksheetToDB', data);
      UI.toast("保存しました");
      if (APP_CONFIG.mode === 'teacher') App.loadHistory();
    } finally {
      UI.hideLoading();
    }
  },

  createPdf: async () => {
    if (!State.currentTask) return;
    UI.showLoading("PDFを作成しています", "サーバーでレンダリング中...");
    try {
      let html = document.getElementById('worksheetContent').innerHTML;
      // キャンバスを画像化して埋め込み
      if (State.fabricCanvas) {
        const img = State.fabricCanvas.toDataURL();
        html += `<img src="${img}" style="position:absolute; top:0; left:0; width:100%; height:100%; z-index:99; pointer-events:none;">`;
      }
      const result = await Server.call('createPdf', html, State.currentTask.title);
      window.open(result.downloadUrl, '_blank');
    } finally {
      UI.hideLoading();
    }
  },

  // --- Student & Grading Logic ---
  
  autoSaveLocal: () => {
    if (APP_CONFIG.mode !== 'student' || !State.currentTask || !State.fabricCanvas) return;
    const key = `manabi_${State.currentTask.id}`;
    localStorage.setItem(key, JSON.stringify({ j: State.fabricCanvas.toJSON(), t: Date.now() }));
    const ind = document.getElementById('autoSaveIndicator');
    if(ind) ind.innerHTML = `<i class="bi bi-cloud-check"></i> ${new Date().toLocaleTimeString()}`;
  },

  loadMyResponse: async () => {
    const resp = await Server.call('getMyResponse', State.currentTask.id, State.studentId);
    if (resp) {
      if (resp.canvasJson && State.fabricCanvas) State.fabricCanvas.loadFromJSON(resp.canvasJson);
      if (resp.feedbackText || resp.status === 'graded') {
        const btn = document.getElementById('btnFeedback');
        if(btn) {
          btn.classList.remove('d-none');
          btn.onclick = () => Swal.fire({ title: '先生からのコメント', text: resp.feedbackText || "（コメントなし）", icon: 'info' });
          UI.toast("添削が届いています");
        }
      }
    } else {
      // Restore Local Draft
      const local = localStorage.getItem(`manabi_${State.currentTask.id}`);
      if (local && State.fabricCanvas) {
        State.fabricCanvas.loadFromJSON(JSON.parse(local).j);
        UI.toast("下書きを復元しました");
      }
    }
  },

  submitStudentResponse: async (status) => {
    const name = document.getElementById('studentNameInput').value;
    if (!name && status === 'submitted') return Swal.fire('名前を入力してください', '', 'warning');
    
    UI.showLoading(status === 'draft' ? "一時保存中..." : "提出しています", "先生にデータを送信中...");
    try {
      let img = "";
      if (State.fabricCanvas) img = State.fabricCanvas.toDataURL({ format: 'png', multiplier: 0.5 });
      
      await Server.call('saveStudentResponse', {
        taskId: State.currentTask.id,
        studentId: State.studentId,
        studentName: name || "名無し",
        canvasImage: img,
        canvasJson: JSON.stringify(State.fabricCanvas?.toJSON()),
        textContent: "",
        status: status
      });
      
      if (status === 'submitted') localStorage.removeItem(`manabi_${State.currentTask.id}`);
      UI.toast(status === 'draft' ? "保存しました" : "提出しました！");
    } finally {
      UI.hideLoading();
    }
  },

  // --- Teacher Grading ---
  openGrading: (index) => {
    const s = State.dashboardData[index];
    State.gradingRow = s.rowIndex;
    
    bootstrap.Modal.getInstance(document.getElementById('dashboardModal')).hide();
    
    const container = document.getElementById('gradingContainer');
    // 現在のワークシート背景を表示
    container.innerHTML = `<div id="gradingPaper" class="sheet shadow-sm"><div class="p-5">${document.getElementById('worksheetContent').innerHTML}</div></div><canvas id="gradingCanvas"></canvas>`;
    
    new bootstrap.Modal(document.getElementById('gradingModal')).show();
    
    setTimeout(() => {
      const paper = document.getElementById('gradingPaper');
      const cv = document.getElementById('gradingCanvas');
      cv.width = paper.offsetWidth;
      cv.height = paper.offsetHeight;
      cv.style.position = 'absolute';
      cv.style.top = paper.offsetTop + 'px';
      cv.style.left = paper.offsetLeft + 'px';
      cv.style.zIndex = 99;
      
      const gCanvas = new fabric.Canvas('gradingCanvas', { isDrawingMode: true });
      gCanvas.freeDrawingBrush.width = 3;
      gCanvas.freeDrawingBrush.color = "red"; // 赤ペン固定
      
      if (s.canvasJson) gCanvas.loadFromJSON(s.canvasJson);
      
      State.gradingCanvas = gCanvas;
      document.getElementById('gradingTitle').innerText = `${s.studentName} さんの回答`;
      document.getElementById('feedbackTextInput').value = s.feedbackText || "";
    }, 500);
  },

  saveGrading: async () => {
    if (!State.gradingRow) return;
    UI.showLoading("返却しています", "コメントと添削内容を保存中...");
    try {
      await Server.call('saveFeedback', {
        rowIndex: State.gradingRow,
        feedbackText: document.getElementById('feedbackTextInput').value,
        canvasJson: JSON.stringify(State.gradingCanvas.toJSON())
      });
      bootstrap.Modal.getInstance(document.getElementById('gradingModal')).hide();
      UI.toast("返却しました");
    } finally {
      UI.hideLoading();
    }
  },

  // --- Other Utils ---
  generateRubric: async () => {
    UI.showLoading("ルーブリック作成中...");
    try {
      let h = await Server.call('generateRubricAI', {
        unitName: "",
        stepTitle: State.currentTask.title,
        description: State.currentTask.description
      });
      h = App.cleanAIOutput(h);
      document.getElementById('rubricContainer').innerHTML = h;
    } finally {
      UI.hideLoading();
    }
  },

  saveRubric: () => {
    State.currentTask.rubricHtml = document.getElementById('rubricContainer').innerHTML;
    App.saveCurrentWorksheet();
    bootstrap.Modal.getInstance(document.getElementById('rubricModal')).hide();
  },

  showShareUrl: async () => {
    if (!State.currentTask) return;
    const url = await Server.call('getWebAppUrl');
    const shareUrl = `${url}?mode=student&taskId=${State.currentTask.id}`;
    document.getElementById('shareUrlInput').value = shareUrl;
    new bootstrap.Modal(document.getElementById('shareModal')).show();
  },

  processOcrImport: async () => { /* OCR Logic (Abbreviated for safety) */ },

  // Fabric Canvas
  initFabric: () => {
    if (!State.fabricCanvas) {
      const c = document.getElementById('drawCanvas');
      if (c) State.fabricCanvas = new fabric.Canvas('drawCanvas', { isDrawingMode: false });
    }
  },

  resetCanvas: () => {
    if (State.fabricCanvas) {
      try { State.fabricCanvas.clear(); State.fabricCanvas.dispose(); } catch(e){}
      State.fabricCanvas = null;
    }
    const cv = document.getElementById('drawCanvas');
    if (cv) cv.classList.add('d-none');
    App.toggleDrawMode(false);
  },

  toggleDrawMode: (forceState) => {
    const newState = (forceState !== undefined) ? forceState : !State.isDrawMode;
    State.isDrawMode = newState;
    
    const btn = document.getElementById('btnDrawMode');
    const tools = document.getElementById('drawTools');
    const cv = document.getElementById('drawCanvas');
    const pp = document.getElementById('paperArea');

    if(btn) btn.classList.replace(newState ? 'btn-outline-dark' : 'btn-dark', newState ? 'btn-dark' : 'btn-outline-dark');
    if(tools) newState ? tools.classList.remove('d-none') : tools.classList.add('d-none');

    if (newState) {
      if(cv) {
        cv.classList.remove('d-none');
        cv.style.position = 'absolute'; cv.style.left = '0'; cv.style.top = '0';
        if(pp) { cv.width = pp.offsetWidth; cv.height = pp.offsetHeight; }
      }
      
      if (!State.fabricCanvas && cv) {
        try { State.fabricCanvas = new fabric.Canvas('drawCanvas', { isDrawingMode: true, freeDrawingBrush: { width: 3, color: '#ff0000' } }); } catch(e){}
      } else if (State.fabricCanvas) {
        State.fabricCanvas.isDrawingMode = true;
      }
      
      if (State.currentTask?.canvasData && State.fabricCanvas) {
        try { State.fabricCanvas.loadFromJSON(State.currentTask.canvasData); } catch(e){}
      }
      const wc = document.getElementById('worksheetContent');
      if(wc) wc.contentEditable = false;
    } else {
      if (State.fabricCanvas) State.fabricCanvas.isDrawingMode = false;
      const cnt = document.querySelector('.canvas-container');
      if(cnt) cnt.style.pointerEvents = 'none';
      const wc = document.getElementById('worksheetContent');
      if(wc) wc.contentEditable = true;
    }
  },

  updateBrush: () => { if (State.fabricCanvas) State.fabricCanvas.freeDrawingBrush.color = document.getElementById('penColor').value; },
  clearCanvas: () => { if (State.fabricCanvas) State.fabricCanvas.clear(); },
  insertImage: (input) => { /* Image Insert Logic (Same as v11.0) */ 
    if(input.files && input.files[0]){
      const r = new FileReader();
      r.onload = e => {
        const i = new Image();
        i.onload = () => {
          const c = document.createElement('canvas'), x = c.getContext('2d'), M = 800;
          let w=i.width, h=i.height;
          if(w>h){if(w>M){h*=M/w;w=M}}else{if(h>M){w*=M/h;h=M}}
          c.width=w; c.height=h; x.drawImage(i,0,0,w,h);
          const u = c.toDataURL('image/jpeg', 0.7);
          
          if(State.isDrawMode && State.fabricCanvas) {
            fabric.Image.fromURL(u, o => {
              o.scaleToWidth(300);
              State.fabricCanvas.add(o);
              State.fabricCanvas.centerObject(o);
            });
          } else {
            App.insertAtCursor(`<img src="${u}" style="max-width:100%; border:1px solid #ccc; display:block; margin:10px auto;">`);
          }
        };
        i.src = e.target.result;
      };
      r.readAsDataURL(input.files[0]);
    }
    input.value = '';
  },
  insertAtCursor: (html) => {
    const e = document.getElementById('worksheetContent');
    e.focus();
    const s = window.getSelection();
    if(s.getRangeAt && s.rangeCount) {
      const r = s.getRangeAt(0);
      if(e.contains(r.commonAncestorContainer)) {
        r.deleteContents();
        const d = document.createElement("div");
        d.innerHTML = html;
        const f = document.createDocumentFragment();
        let n;
        while((n=d.firstChild)) f.appendChild(n);
        r.insertNode(f);
        return;
      }
    }
    e.insertAdjacentHTML('beforeend', html);
  }
};

document.addEventListener('DOMContentLoaded', App.init);
</script>
